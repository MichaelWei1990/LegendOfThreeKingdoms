# 结构化日志模型技术规划（PLAN）

> 聚焦于 `core_module_breakdown.md` 中的 **17. 结构化日志模型**，定义结构化的日志事件模型（LogEvent/ReplayEvent），用于记录游戏中的关键事件（时间顺序、事件类型、关键信息），并将事件系统和 resolver 中的关键节点映射到日志事件。

---

## 1. 范围与目标

- **范围（Scope）**
  - 在 `core` Class Library 中实现结构化日志模型：
    - 定义 `ILogEvent` 接口和 `ILogCollector` 接口
    - 定义具体的日志事件类型（TurnStartLogEvent, CardUsedLogEvent, DamageAppliedLogEvent 等）
    - 实现 `BasicLogCollector` 类，支持事件收集和序列号管理
    - 实现 `LogEventMapper`，将 `IGameEvent` 映射为 `ILogEvent`
    - 实现事件总线扩展方法，自动订阅并收集日志事件
    - 在 `ResolutionContext` 中添加 `LogCollector` 可选字段
    - 在关键 resolver（UseCardResolver, SlashResolver）中添加日志记录
    - 实现日志事件的序列化支持（JSON），便于持久化
  - 约束：
    - **不实现持久化**（文件、数据库等），仅提供序列化接口
    - **不实现回放功能**（将在步骤 18 实现），仅记录事件
    - **不覆盖所有事件类型**，先实现关键事件类型

- **目标（Goals）**
  - **结构化记录**：所有关键游戏事件都有对应的结构化日志事件类型
  - **时间顺序保证**：通过序列号机制保证事件顺序
  - **可扩展性**：支持未来添加新的事件类型
  - **可序列化**：支持 JSON 序列化，便于持久化和传输
  - **可选集成**：日志收集器是可选的，不影响核心游戏逻辑

- **非目标（Non-Goals）**
  - 不实现持久化存储（文件、数据库等）
  - 不实现回放功能（步骤 18）
  - 不实现日志事件的过滤和查询功能
  - 不实现日志压缩和归档

---

## 2. 与现有模块的关系

### 2.1 上游依赖

- **事件系统**（见 `core/Events.Abstractions.cs` 和 `core/Events.Basic.cs`）
  - `IGameEvent` 接口：所有游戏事件的基础接口
  - `IEventBus`：事件总线，支持发布和订阅
  - 已有事件类型：`TurnStartEvent`, `TurnEndEvent`, `PhaseStartEvent`, `PhaseEndEvent`, `DamageCreatedEvent`, `DamageAppliedEvent`, `DyingStartEvent`, `PlayerDiedEvent`, `CardMovedEvent`
  - 需要将 `IGameEvent` 映射为 `ILogEvent`

- **Resolver 系统**（见 `core/Resolution.Basic.cs`）
  - `ResolutionContext`：需要添加 `ILogCollector?` 可选字段
  - `UseCardResolver`：需要记录 `CardUsedLogEvent`
  - 其他关键 resolver 也需要记录相应事件

- **现有日志系统**（见 `core/Abstractions.ILogSink.cs`）
  - `ILogSink` 和 `LogEntry`：用于运行时日志
  - 保留现有系统，`ILogEvent` 用于结构化日志记录

### 2.2 下游被依赖方

- **回放系统**（步骤 18）
  - 结构化日志事件将作为回放数据的基础
  - 回放系统将读取日志事件序列重建游戏状态

- **战报生成**
  - 日志事件可用于生成游戏战报
  - 支持关键事件摘要和统计

---

## 3. 命名空间与文件布局

- **命名空间**
  - 新建 `LegendOfThreeKingdoms.Core.Logging` 命名空间
  - 依赖 `LegendOfThreeKingdoms.Core.Model`、`LegendOfThreeKingdoms.Core.Events`、`LegendOfThreeKingdoms.Core.Resolution`、`LegendOfThreeKingdoms.Core.Response`、`LegendOfThreeKingdoms.Core.Rules`

- **文件结构**
  - `core/Logging.Abstractions.cs`：
    - `ILogEvent` 接口定义
    - `LogEvent` 抽象记录类型
    - `ILogCollector` 接口定义
  - `core/Logging.Events.cs`：
    - 具体日志事件类型定义（TurnStartLogEvent, CardUsedLogEvent, DamageAppliedLogEvent 等）
  - `core/Logging.Basic.cs`：
    - `BasicLogCollector` 类实现
  - `core/Logging.Mapping.cs`：
    - `LogEventMapper` 静态类，实现 `IGameEvent` 到 `ILogEvent` 的映射
  - `core/Logging.Extensions.cs`：
    - 事件总线扩展方法 `SubscribeToLogCollector`
  - `core/Logging.Serialization.cs`：
    - `LogEventSerialization` 静态类，提供 JSON 序列化/反序列化支持

---

## 4. 核心抽象与数据结构

### 4.1 ILogEvent（日志事件接口）

定义在 `core/Logging.Abstractions.cs`：

```csharp
public interface ILogEvent
{
    DateTime Timestamp { get; }
    long SequenceNumber { get; }
    string EventType { get; }
    Game Game { get; }
    object? Data { get; }
}
```

- `Timestamp`：事件发生时间（UTC）
- `SequenceNumber`：事件序列号，用于保证顺序
- `EventType`：事件类型标识（如 "TurnStart", "DamageApplied", "CardUsed"）
- `Game`：关联的游戏实例
- `Data`：可选的结构化数据载荷

### 4.2 LogEvent（基础记录类型）

定义在 `core/Logging.Abstractions.cs`：

```csharp
public abstract record LogEvent(
    DateTime Timestamp,
    long SequenceNumber,
    string EventType,
    Game Game,
    object? Data = null
) : ILogEvent;
```

- 所有具体日志事件类型的基类
- 使用 record 类型，支持值相等性比较

### 4.3 ILogCollector（日志收集器接口）

定义在 `core/Logging.Abstractions.cs`：

```csharp
public interface ILogCollector
{
    void Collect(ILogEvent logEvent);
    IReadOnlyList<ILogEvent> GetEvents();
    void Clear();
    long GetNextSequenceNumber();
}
```

- `Collect`：收集日志事件
- `GetEvents`：获取所有收集的事件（按顺序）
- `Clear`：清空收集的事件
- `GetNextSequenceNumber`：获取下一个序列号

### 4.4 具体日志事件类型

定义在 `core/Logging.Events.cs`：

- **TurnStartLogEvent**：记录回合开始
  - `int PlayerSeat`, `int TurnNumber`
- **TurnEndLogEvent**：记录回合结束
  - `int PlayerSeat`, `int TurnNumber`
- **PhaseStartLogEvent**：记录阶段开始
  - `int PlayerSeat`, `Phase Phase`
- **PhaseEndLogEvent**：记录阶段结束
  - `int PlayerSeat`, `Phase Phase`
- **CardUsedLogEvent**：记录使用牌
  - `int SourcePlayerSeat`, `int CardId`, `CardSubType CardSubType`, `IReadOnlyList<int>? TargetSeats`
- **DamageAppliedLogEvent**：记录伤害应用
  - `int SourceSeat`, `int TargetSeat`, `int Amount`, `DamageType Type`, `int PreviousHealth`, `int CurrentHealth`
- **CardMovedLogEvent**：记录牌移动
  - `int CardId`, `string FromZone`, `string ToZone`, `int? FromOwnerSeat`, `int? ToOwnerSeat`
- **DyingStartLogEvent**：记录进入濒死
  - `int DyingPlayerSeat`
- **PlayerDiedLogEvent**：记录玩家死亡
  - `int DeadPlayerSeat`, `int? KillerSeat`
- **ResponseWindowOpenedLogEvent**：记录响应窗口开启
  - `ResponseType ResponseType`, `IReadOnlyList<int> ResponderSeats`
- **ResponseCardPlayedLogEvent**：记录响应牌打出
  - `int ResponderSeat`, `int CardId`, `ResponseType ResponseType`

### 4.5 BasicLogCollector（基础日志收集器）

定义在 `core/Logging.Basic.cs`：

```csharp
public sealed class BasicLogCollector : ILogCollector
{
    private readonly List<ILogEvent> _events = new();
    private long _sequenceCounter = 0;
    private readonly object _lock = new();

    // 实现接口方法，支持线程安全
}
```

- 使用 `List<ILogEvent>` 存储事件
- 维护序列号计数器
- 支持线程安全（使用 lock）

### 4.6 LogEventMapper（事件映射器）

定义在 `core/Logging.Mapping.cs`：

```csharp
public static class LogEventMapper
{
    public static ILogEvent? MapFromGameEvent(IGameEvent gameEvent, long sequenceNumber)
    {
        // 将 IGameEvent 映射为 ILogEvent
        // 支持所有现有的事件类型映射
        // 对于无法映射的事件，返回 null
    }
}
```

- 静态类，提供事件映射功能
- 支持所有现有的事件类型映射
- 对于不支持的事件类型，返回 `null`

---

## 5. 集成点修改

### 5.1 修改 ResolutionContext

在 `core/Resolution.Abstractions.cs` 中扩展 `ResolutionContext`：

```csharp
public sealed record ResolutionContext(
    Game Game,
    Player SourcePlayer,
    ActionDescriptor? Action,
    ChoiceResult? Choice,
    IResolutionStack Stack,
    ICardMoveService CardMoveService,
    IRuleService RuleService,
    DamageDescriptor? PendingDamage = null,
    ILogSink? LogSink = null,
    Func<ChoiceRequest, ChoiceResult>? GetPlayerChoice = null,
    Dictionary<string, object>? IntermediateResults = null,
    IEventBus? EventBus = null,
    ILogCollector? LogCollector = null  // 新增字段
);
```

- 添加 `ILogCollector? LogCollector = null` 可选字段
- 更新所有创建 `ResolutionContext` 的地方，传递 `LogCollector`

### 5.2 修改 UseCardResolver

在 `core/Resolution.Basic.cs` 中修改 `UseCardResolver.Resolve` 方法：

在牌使用成功后，记录 `CardUsedLogEvent`：

```csharp
// Log card usage event if log collector is available
if (context.LogCollector is not null)
{
    var sequenceNumber = context.LogCollector.GetNextSequenceNumber();
    var targetSeats = choice.SelectedTargetSeats?.ToList();
    var logEvent = new CardUsedLogEvent(
        DateTime.UtcNow,
        sequenceNumber,
        game,
        sourcePlayer.Seat,
        card.Id,
        card.CardSubType,
        targetSeats
    );
    context.LogCollector.Collect(logEvent);
}
```

### 5.3 事件总线集成

在 `core/Logging.Extensions.cs` 中实现扩展方法：

```csharp
public static class LoggingExtensions
{
    public static IEventBus SubscribeToLogCollector(this IEventBus eventBus, ILogCollector logCollector)
    {
        // 订阅所有 IGameEvent 类型
        // 通过 LogEventMapper 转换为 ILogEvent 并收集
        return eventBus;
    }
}
```

- 为每个具体事件类型订阅（因为 `IEventBus.Subscribe<T>` 需要具体类型）
- 自动将 `IGameEvent` 映射为 `ILogEvent` 并收集

---

## 6. 序列化支持

### 6.1 LogEventSerialization（序列化工具类）

定义在 `core/Logging.Serialization.cs`：

```csharp
public static class LogEventSerialization
{
    private static readonly JsonSerializerOptions DefaultOptions = new()
    {
        WriteIndented = true,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,
        Converters = { new JsonStringEnumConverter() }
    };

    public static string SerializeToJson(ILogEvent logEvent, JsonSerializerOptions? options = null);
    public static string SerializeToJson(IEnumerable<ILogEvent> logEvents, JsonSerializerOptions? options = null);
    public static ILogEvent? DeserializeFromJson(string json, JsonSerializerOptions? options = null);
    public static IReadOnlyList<ILogEvent> DeserializeArrayFromJson(string json, JsonSerializerOptions? options = null);
}
```

- 使用 `System.Text.Json` 进行序列化
- 支持单个事件和事件数组的序列化/反序列化
- 提供默认的 JSON 序列化选项（驼峰命名、缩进、忽略 null 值等）

---

## 7. 实现步骤

### 阶段 1：基础抽象和接口定义
1. 创建 `core/Logging.Abstractions.cs`，定义 `ILogEvent`、`LogEvent`、`ILogCollector` 接口
2. 创建 `core/Logging.Events.cs`，定义所有具体日志事件类型

### 阶段 2：基础实现
3. 创建 `core/Logging.Basic.cs`，实现 `BasicLogCollector` 类
4. 创建 `core/Logging.Mapping.cs`，实现 `LogEventMapper` 类

### 阶段 3：集成
5. 创建 `core/Logging.Extensions.cs`，实现事件总线扩展方法
6. 修改 `core/Resolution.Abstractions.cs`，在 `ResolutionContext` 中添加 `LogCollector` 字段
7. 修改 `core/Resolution.Basic.cs`，更新所有创建 `ResolutionContext` 的地方
8. 修改 `UseCardResolver`，添加日志记录

### 阶段 4：序列化支持
9. 创建 `core/Logging.Serialization.cs`，实现序列化功能

### 阶段 5：测试
10. 创建 `core.Tests/LoggingTests.cs`，编写单元测试
11. 运行所有测试，确保功能正常且不破坏现有功能

---

## 8. 关键设计决策

1. **序列号机制**：使用 `long` 类型的序列号保证事件顺序，由 `ILogCollector` 统一分配
2. **事件类型分离**：`IGameEvent` 用于事件总线，`ILogEvent` 用于日志记录，两者通过映射器转换
3. **可选集成**：日志收集器是可选的，不影响核心游戏逻辑
4. **结构化数据**：每个具体事件类型包含强类型的字段，而不是仅使用 `object? Data`
5. **线程安全**：`BasicLogCollector` 使用 lock 保证线程安全
6. **序列化格式**：使用 JSON 格式，支持驼峰命名和缩进，便于阅读和调试

---

## 9. 测试策略

### 9.1 单元测试覆盖

- **BasicLogCollector 测试**
  - 事件收集和存储
  - 序列号递增
  - 清空功能
  - 返回只读列表
  - 空值检查

- **LogEventMapper 测试**
  - 各种事件类型的映射
  - 不支持的事件类型返回 null
  - 空事件处理

- **事件总线集成测试**
  - 订阅并收集事件
  - 多个事件收集
  - 空值检查

- **Resolver 日志记录测试**
  - UseCardResolver 记录 CardUsedLogEvent
  - 无 LogCollector 时不抛异常

- **序列化测试**
  - 单个事件序列化
  - 事件数组序列化
  - 空值/空字符串处理
  - 异常处理

### 9.2 集成测试

- 验证事件总线自动收集日志事件
- 验证 resolver 正确记录日志事件
- 验证序列化/反序列化完整性

---

## 10. 后续扩展

- 支持日志事件的过滤和查询
- 支持日志事件的持久化（文件、数据库）
- 与回放系统集成（第18步）
- 支持日志事件的压缩和归档
- 支持多态序列化（完整还原具体事件类型）
- 支持日志事件的统计和分析

---

## 11. 注意事项

1. **性能考虑**：日志收集可能影响性能，确保日志收集器是可选的
2. **内存管理**：长时间运行的游戏可能产生大量日志事件，考虑实现日志轮转或限制
3. **序列化兼容性**：未来修改事件结构时，需要考虑向后兼容性
4. **Game 对象引用**：日志事件包含 Game 对象引用，注意内存泄漏问题









