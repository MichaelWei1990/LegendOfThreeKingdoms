# 技能模型与注册机制技术规划（PLAN）

> 聚焦于 `core_module_breakdown.md` 中的 **15.技能模型与注册机制**，为技能系统建立基础架构。该模块是事件系统与技能引擎的基础，为后续技能介入结算与规则判断（第16项）提供支撑。

---

## 1. 范围与目标

- **范围（Scope）**：
  - 在 `core` Class Library 中，基于既有 **事件总线（IEventBus）** 和 **模型层（Game/Player）**，实现技能系统的核心抽象与注册机制。
  - 定义技能基类/接口，支持不同技能类型（主动/触发/锁定）和能力标记。
  - 实现技能注册中心 `SkillRegistry`，支持根据武将ID或技能ID查找技能。
  - 实现技能管理器 `SkillManager`，负责技能的加载和生命周期管理。
  - 实现1-2个简单的被动技能示例（如"额外摸牌"、"杀次数+1"）。

- **目标（Goals）**：
  - **可扩展**：通过接口和工厂模式，支持未来添加新的技能类型和实现。
  - **可测试**：所有技能组件均可在"无 UI / 无网络 / 仅给定 Game & Player 状态"的前提下进行单元测试。
  - **生命周期管理**：技能可以正确附加到玩家、订阅事件、并在移除时清理资源。
  - **解耦**：技能通过事件总线响应游戏事件，不直接依赖游戏状态修改逻辑。

- **非目标（Non-Goals）**：
  - 不在本阶段实现技能对规则判断的修改逻辑（将在第16项"技能介入结算与规则判断"中实现）。
  - 不实现复杂的技能交互和优先级机制。
  - 不处理技能的选择请求和玩家交互（这些将在后续阶段实现）。

---

## 2. 与现有模块的关系

### 2.1 上游依赖

- **事件总线（已在第14项实现）**：
  - `IEventBus`：技能通过订阅事件总线来响应游戏事件（如 `PhaseStartEvent`, `TurnStartEvent` 等）。
  - `IGameEvent`：所有游戏事件的基础接口。

- **模型层（已在 `02.02_ModelLayerGamePlayerCardZone_PLAN.md` 规划）**：
  - `Game`：当前游戏状态，包含玩家列表、当前回合信息等。
  - `Player`：玩家状态，包含 `HeroId` 字段用于关联技能。

- **枚举与基础类型层（`02.03_EnumsAndBasicTypes_PLAN.md`）**：
  - `Phase`（准备/判定/摸牌/出牌/弃牌/结束）。
  - 需要新增：`SkillType`（主动/触发/锁定）和 `SkillCapability`（能力标记枚举）。

- **牌移动服务（`02.08_CardMoveAndZones_PLAN.md`）**：
  - `ICardMoveService`：某些技能（如"额外摸牌"）需要调用牌移动服务来执行效果。

### 2.2 下游被依赖方

- **技能介入结算与规则判断（第16项，后续实现）**：
  - 技能系统将提供接口，允许技能修改规则判断（如出牌次数上限、目标范围等）。
  - 技能可以介入结算流程（如修改伤害值、替换效果等）。

- **游戏初始化（`02.07_GameInitializationAndOpening_PLAN.md`）**：
  - 在游戏初始化时，可以通过 `SkillManager` 为玩家加载技能。

---

## 3. 模块划分与命名建议

在 `core` 项目中，为技能层建议如下命名空间与文件布局：

- `LegendOfThreeKingdoms.Core.Skills`：技能层根命名空间
  - `Skills.Abstractions.cs`：技能接口定义（`ISkill`, `ISkillFactory`）
  - `Skills.Basic.cs`：基础技能实现和示例技能（`BaseSkill`, `ExtraDrawSkill`, `ExtraSlashSkill`）
  - `Skills.Registry.cs`：技能注册中心（`SkillRegistry`）
  - `Skills.Manager.cs`：技能管理器（`SkillManager`）

在 `core/Model` 中：

- `Model/Enums.cs`：添加 `SkillType` 和 `SkillCapability` 枚举

---

## 4. 核心抽象设计

### 4.1 技能类型枚举

在 `Model/Enums.cs` 中定义：

```csharp
public enum SkillType
{
    /// <summary>
    /// Active skill: requires player to actively choose to activate.
    /// </summary>
    Active,
    
    /// <summary>
    /// Trigger skill: automatically triggers or asks player when specific events occur.
    /// </summary>
    Trigger,
    
    /// <summary>
    /// Locked skill: continuously active, no need to activate manually.
    /// </summary>
    Locked
}
```

### 4.2 技能能力标记枚举

在 `Model/Enums.cs` 中定义：

```csharp
[Flags]
public enum SkillCapability
{
    None = 0,
    
    /// <summary>
    /// Provides additional actions (e.g., extra play phase).
    /// </summary>
    ProvidesActions = 1 << 0,
    
    /// <summary>
    /// Modifies rule judgments (e.g., modifies usage count, target range).
    /// </summary>
    ModifiesRules = 1 << 1,
    
    /// <summary>
    /// Intervenes in resolution (e.g., modifies damage value, replaces effects).
    /// </summary>
    IntervenesResolution = 1 << 2,
    
    /// <summary>
    /// Initiates choice requests (e.g., select cards, select targets).
    /// </summary>
    InitiatesChoices = 1 << 3
}
```

### 4.3 技能接口

**`ISkill` 接口**（在 `Skills.Abstractions.cs` 中定义）：

- `string Id { get; }` - 技能唯一标识符
- `string Name { get; }` - 技能名称（用于日志/UI）
- `SkillType Type { get; }` - 技能类型
- `SkillCapability Capabilities { get; }` - 技能能力标记
- `bool IsActive(Game game, Player owner)` - 判断技能是否激活（用于锁定技的启用/禁用判断）
- `void Attach(Game game, Player owner, IEventBus eventBus)` - 将技能附加到玩家，订阅相关事件
- `void Detach(Game game, Player owner, IEventBus eventBus)` - 从玩家移除技能，取消订阅

**`ISkillFactory` 接口**（在 `Skills.Abstractions.cs` 中定义）：

- `ISkill CreateSkill()` - 创建技能实例的工厂方法

### 4.4 技能注册中心

**`SkillRegistry` 类**（在 `Skills.Registry.cs` 中实现）：

- **核心功能**：
  - `RegisterSkill(string skillId, ISkillFactory factory)` - 注册技能工厂
  - `RegisterHeroSkills(string heroId, IEnumerable<string> skillIds)` - 注册武将技能映射
  - `GetSkill(string skillId)` - 根据技能ID查找技能实例
  - `GetSkillsForHero(string heroId)` - 根据武将ID查找技能实例列表
  - `IsSkillRegistered(string skillId)` - 检查技能是否已注册
  - `HasHeroSkills(string heroId)` - 检查武将是否有注册的技能
  - `Clear()` - 清空注册表（用于测试）

- **数据结构**：
  - `Dictionary<string, ISkillFactory> _skillFactories` - 技能ID到工厂的映射
  - `Dictionary<string, List<string>> _heroSkillMap` - 武将ID到技能ID列表的映射

### 4.5 技能管理器

**`SkillManager` 类**（在 `Skills.Manager.cs` 中实现）：

- **职责**：
  - 管理玩家当前激活的技能列表
  - 在游戏初始化时为玩家加载并附加技能（基于 `Player.HeroId`）
  - 提供查询接口：`GetActiveSkills(Game game, Player player)` 和 `GetAllSkills(Player player)`
  - 处理技能的附加/移除生命周期

- **与事件总线的集成**：
  - `SkillManager` 持有 `IEventBus` 引用
  - 在附加技能时，调用 `skill.Attach(game, player, eventBus)`
  - 在移除技能时，调用 `skill.Detach(game, player, eventBus)`

---

## 5. 实现细节

### 5.1 基础技能实现

**`BaseSkill` 抽象类**（在 `Skills.Basic.cs` 中实现）：

- 实现 `ISkill` 接口的基础功能
- 提供默认的 `Attach`/`Detach` 实现（空操作，子类可重写）
- 提供 `IsActive` 的默认实现（返回 `owner.IsAlive`）

### 5.2 示例技能1：额外摸牌（ExtraDrawSkill）

- **类型**：`SkillType.Locked`
- **能力**：`SkillCapability.ModifiesRules`
- **功能**：在 `PhaseStartEvent`（阶段为 `Phase.Draw`）时，为拥有者额外摸1张牌
- **实现方式**：
  - 在 `Attach` 方法中订阅 `PhaseStartEvent`
  - 在事件处理中检查是否为拥有者的摸牌阶段
  - 调用 `ICardMoveService.DrawCards` 额外摸1张牌
  - 在 `Detach` 方法中取消订阅

- **依赖注入**：
  - 技能实例可以通过构造函数或 `SetCardMoveService` 方法接收 `ICardMoveService`
  - 如果 `ICardMoveService` 为 null，技能将无法执行抽牌操作（静默失败）

### 5.3 示例技能2：杀次数+1（ExtraSlashSkill）

- **类型**：`SkillType.Locked`
- **能力**：`SkillCapability.ModifiesRules`
- **功能**：修改玩家每回合使用【杀】的次数上限（从1变为2）
- **注意**：实际的规则修改逻辑需要在第16项"技能介入结算与规则判断"中实现，这里只建立技能框架

### 5.4 技能与事件总线的集成模式

技能通过订阅事件总线来响应游戏事件：

```csharp
public void Attach(Game game, Player owner, IEventBus eventBus)
{
    _game = game;
    _owner = owner;
    _eventBus = eventBus;
    eventBus.Subscribe<PhaseStartEvent>(OnPhaseStart);
}

private void OnPhaseStart(PhaseStartEvent evt)
{
    if (evt.PlayerSeat != _owner.Seat || evt.Phase != Phase.Draw)
        return;
    
    if (!IsActive(_game, _owner))
        return;
    
    // 执行技能效果
}

public void Detach(Game game, Player owner, IEventBus eventBus)
{
    eventBus.Unsubscribe<PhaseStartEvent>(OnPhaseStart);
    _game = null;
    _owner = null;
    _eventBus = null;
}
```

### 5.5 技能注册流程

在游戏初始化时（或通过配置），注册技能：

```csharp
var registry = new SkillRegistry();
registry.RegisterSkill("extra_draw", new ExtraDrawSkillFactory(cardMoveService));
registry.RegisterSkill("extra_slash", new ExtraSlashSkillFactory());
registry.RegisterHeroSkills("hero_zhangfei", new[] { "extra_slash" });

var eventBus = new BasicEventBus();
var skillManager = new SkillManager(registry, eventBus);
skillManager.LoadSkillsForAllPlayers(game);
```

---

## 6. 文件结构

需要创建/修改的文件：

**新建文件**：
- `core/Skills.Abstractions.cs` - 技能接口定义
- `core/Skills.Basic.cs` - 基础技能实现和示例技能
- `core/Skills.Registry.cs` - 技能注册中心
- `core/Skills.Manager.cs` - 技能管理器

**修改文件**：
- `core/Model/Enums.cs` - 添加 `SkillType` 和 `SkillCapability` 枚举

**测试文件**（可选，不在本计划范围内）：
- `core.Tests/SkillsTests.cs` - 技能系统单元测试

---

## 7. 实现注意事项

1. **技能实例化**：每个玩家应该拥有独立的技能实例，避免状态共享问题。通过工厂模式确保每次调用 `CreateSkill()` 都返回新实例。

2. **事件订阅管理**：技能在 `Attach` 时订阅事件，在 `Detach` 时必须取消订阅，防止内存泄漏。建议在技能内部保存事件处理器的引用，以便正确取消订阅。

3. **技能激活判断**：锁定技的 `IsActive` 方法可用于判断技能是否在当前状态下生效（如某些技能在特定条件下失效）。默认实现检查玩家是否存活。

4. **扩展性**：接口设计应支持未来添加限定技、觉醒技等扩展类型。可以通过扩展 `SkillType` 枚举来实现。

5. **与规则服务的集成**：本阶段只建立技能框架，实际的规则修改逻辑（如修改出牌次数）将在第16项中通过规则服务的扩展点实现。

6. **错误处理**：技能执行过程中的异常应该被捕获并静默处理，避免影响其他技能和游戏流程。在生产环境中，应该记录日志。

7. **线程安全**：当前实现假设单线程环境。如果未来需要支持多线程，需要在 `SkillRegistry` 和 `SkillManager` 中添加同步机制。

---

## 8. 依赖关系

```
EventBus (第14项，已实现)
    ↓
ISkill, SkillRegistry, SkillManager (本计划)
    ↓
技能介入结算与规则判断 (第16项，后续实现)
```

---

## 9. 测试建议

建议为以下组件编写单元测试：

1. **SkillRegistry**：
   - 注册技能并检索
   - 注册武将技能映射
   - 处理重复注册和无效ID
   - 清空注册表

2. **SkillManager**：
   - 为玩家加载技能
   - 获取激活技能
   - 移除玩家技能
   - 处理没有HeroId的玩家

3. **BaseSkill**：
   - 默认的 `IsActive` 实现
   - 默认的 `Attach`/`Detach` 实现（空操作）

4. **ExtraDrawSkill**：
   - 订阅事件并触发
   - 只在正确的阶段和玩家触发
   - 正确取消订阅
   - 处理缺少 `ICardMoveService` 的情况

5. **技能工厂**：
   - 每次调用 `CreateSkill()` 返回新实例

---

## 10. 后续扩展方向

1. **技能优先级系统**：为技能添加优先级，确保某些技能在其他技能之前执行。

2. **技能条件系统**：支持更复杂的技能激活条件（如"当体力≤2时"、"当手牌数≥5时"等）。

3. **技能冷却机制**：为主动技和触发技添加冷却时间或使用次数限制。

4. **技能链式触发**：支持技能触发其他技能（如"当你使用【杀】时，可以额外使用一张【杀】"）。

5. **技能状态持久化**：支持保存和恢复技能状态，用于回放和断线重连。









