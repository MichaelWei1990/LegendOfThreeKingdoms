# Response System 骨架技术规划（PLAN）

> 聚焦于 `core_module_breakdown.md` 中的 **11. Response System 骨架**，在已有 **Resolution Pipeline（UseCard & Slash）** 和 **规则服务（Rules）** 基础上，实现响应窗口结构和基础轮询逻辑，为后续完善 Slash + Jink 流程（步骤 12）提供基础。

---

## 1. 范围与目标

- **范围（Scope）**
  - 在 `core` Class Library 中实现 Response System 骨架：
    - 定义响应窗口结构：`ResponseWindow`、`ResponseOpportunity` 等核心抽象
    - 实现基础轮询逻辑：按顺序询问玩家是否打出响应牌（如【闪】）
    - 支持两种结束条件："无人响应"和"有响应则生效"
  - 约束：
    - **不完善 Slash + Jink 流程**（将在步骤 12 实现），本步骤只提供响应系统骨架
    - **不实现复杂响应链**（如追击、替换响应等），先仅支持基础轮询
    - **不引入事件总线**（将在步骤 14 实现），但为未来事件发布预留接口
    - **不实现濒死响应**（将在步骤 13 实现），先仅支持【闪】响应【杀】的场景

- **目标（Goals）**
  - **可插拔设计**：响应窗口通过接口注册，便于后续扩展（如濒死救援、锦囊响应等）
  - **顺序轮询**：按游戏规则顺序询问玩家是否响应，支持跳过（不响应）
  - **状态驱动**：响应窗口状态可追踪，便于调试和日志记录
  - **可测试**：通过单元测试覆盖轮询流程和结束条件

- **非目标（Non-Goals）**
  - 不完善 Slash + Jink 的完整流程（步骤 12）
  - 不实现复杂响应链机制（如追击、替换响应等）
  - 不实现完整事件总线（步骤 14）
  - 不实现濒死与救援流程（步骤 13）

---

## 2. 与现有模块的关系

### 2.1 上游依赖

- **Resolution Pipeline**（见 `core/Resolution.Basic.cs`）
  - `IResolver` 接口：响应窗口可以作为 resolver 推入结算栈
  - `ResolutionContext`：提供游戏状态、玩家信息、服务依赖
  - `IResolutionStack`：用于管理响应窗口的执行
  - `SlashResolver`：在后续步骤 12 中将触发响应窗口

- **规则服务层**（见 `core/Rules.Basic.cs`）
  - `IResponseRuleService`：判断玩家是否有资格响应、哪些牌可以作为响应
  - `ResponseContext`：响应规则判断的上下文
  - `ResponseType`：响应类型枚举（`JinkAgainstSlash`、`PeachForDying` 等）

- **动作与选择层**（见 `core/Actions.Basic.cs`）
  - `IChoiceRequestFactory`：用于创建响应窗口的选择请求
  - `ChoiceRequest` / `ChoiceResult`：响应窗口与玩家交互的 DTO

- **模型层**
  - `Game` / `Player` / `Card`：响应窗口需要访问游戏状态和玩家信息

### 2.2 下游被依赖方

- **完善 Slash + Jink 流程**（步骤 12）
  - `SlashResolver` 将使用响应系统，在杀命中前开启响应窗口

- **濒死流程**（步骤 13）
  - 濒死救援将使用响应系统，轮询队友是否打出【桃】

- **事件总线与技能引擎**（步骤 14-16）
  - 响应窗口在关键节点发布事件，供技能系统订阅和介入

- **日志与回放系统**（步骤 17-18）
  - 响应窗口的状态变化将用于生成结构化日志和回放记录

---

## 3. 命名空间与文件布局

- **命名空间**
  - 引入新的功能命名空间：`LegendOfThreeKingdoms.Core.Response`：
    - 专注于"响应窗口"的核心抽象与实现
    - 依赖 `LegendOfThreeKingdoms.Core.Model`、`LegendOfThreeKingdoms.Core.Rules`、`LegendOfThreeKingdoms.Core.Resolution`、`LegendOfThreeKingdoms.Core.Actions`

- **文件结构建议**
  - `core/Response.Abstractions.cs`：
    - `IResponseWindow`：响应窗口接口
    - `ResponseOpportunity`：响应机会描述（哪个玩家、响应类型、可用牌等）
    - `ResponseWindowResult`：响应窗口结果（无人响应/有响应/响应失败等）
    - `ResponseWindowState`：响应窗口状态枚举
  - `core/Response.Basic.cs`：
    - `BasicResponseWindow`：基础响应窗口实现
    - `ResponseWindowResolver`：将响应窗口作为 resolver 的实现
  - `core/Response.Extensions.cs`：
    - `ResponseExtensions`：扩展方法，用于在 Resolution Pipeline 中创建响应窗口

> 命名风格与 `Resolution.Abstractions.cs` / `Resolution.Basic.cs`、`Zones.Abstractions.cs` / `Zones.Basic.cs` 保持一致。

---

## 4. 核心抽象与数据结构

### 4.1 IResponseWindow 接口

- **职责**：定义响应窗口的执行契约
- **核心方法**：
  - `ResponseWindowResult Execute(ResponseWindowContext context, Func<ChoiceRequest, ChoiceResult> getPlayerChoice)`：
    - 接收响应窗口上下文，执行轮询逻辑，返回结果
    - 内部按顺序询问玩家是否响应，直到满足结束条件
    - `getPlayerChoice` 函数由上层引擎提供，用于获取玩家选择

### 4.2 ResponseWindowContext（响应窗口上下文）

- **字段示意**：
  - `Game Game`：当前对局状态（可变，响应窗口可修改）
  - `ResponseType ResponseType`：响应类型（如 `JinkAgainstSlash`）
  - `IReadOnlyList<Player> ResponderOrder`：响应顺序（按座次或规则确定）
  - `object? SourceEvent`：触发响应的事件（如 Slash 事件）
  - `IRuleService RuleService`：规则服务（依赖注入）
  - `IResponseRuleService ResponseRuleService`：响应规则服务（依赖注入）
  - `IChoiceRequestFactory ChoiceFactory`：选择请求工厂（依赖注入）
  - `ICardMoveService CardMoveService`：牌移动服务（依赖注入，用于打出响应牌）
  - `ILogSink? LogSink`：日志服务（可选）

- **设计原则**：
  - 上下文对象包含执行响应窗口所需的所有依赖
  - 上下文中的 `Game` 是可变的，响应窗口可以修改状态（如打出响应牌）

### 4.3 ResponseOpportunity（响应机会）

- **字段示意**：
  - `Player Responder`：当前可以响应的玩家
  - `ResponseType ResponseType`：响应类型
  - `IReadOnlyList<Card> LegalCards`：可用的响应牌列表
  - `ChoiceRequest ChoiceRequest`：选择请求（是否响应、选择哪张牌）

- **设计原则**：
  - 每个响应机会对应一个玩家的响应窗口
  - 包含该玩家可以使用的响应牌信息

### 4.4 ResponseWindowResult（响应窗口结果）

- **字段示意**：
  - `ResponseWindowState State`：响应窗口结束状态
  - `Player? Responder`：如果成功响应，记录响应的玩家（可选）
  - `Card? ResponseCard`：如果成功响应，记录响应的牌（可选）
  - `ChoiceResult? Choice`：玩家的选择结果（可选）

- **ResponseWindowState 枚举**：
  - `NoResponse`：无人响应
  - `ResponseSuccess`：有玩家成功响应
  - `ResponseFailed`：响应失败（预留，当前不使用）

### 4.5 ResponseWindowResolver（响应窗口 Resolver）

- **职责**：
  - 将响应窗口作为 `IResolver` 实现，可以推入 `IResolutionStack`
  - 内部创建 `BasicResponseWindow` 并执行

- **设计原则**：
  - 响应窗口可以作为 resolver 推入结算栈，与现有 Resolution Pipeline 无缝集成
  - 响应窗口执行完成后，根据结果决定后续流程（如是否触发伤害）

---

## 5. 轮询逻辑实现

### 5.1 BasicResponseWindow 实现

- **核心流程**：
  1. 根据 `ResponderOrder` 顺序遍历玩家
  2. 对每个玩家：
     - 使用 `IResponseRuleService` 判断是否有资格响应
     - 如果有资格，使用 `IChoiceRequestFactory.CreateForResponse()` 创建选择请求
     - 等待玩家选择（通过 `ChoiceResult`，由上层引擎提供）
     - 如果玩家选择响应：
       - 验证选择的牌是否合法
       - 使用 `ICardMoveService` 将响应牌从手牌移动到弃牌堆
       - 返回 `ResponseWindowResult(State: ResponseSuccess, Responder: player, ResponseCard: card)`
     - 如果玩家选择不响应（跳过）：
       - 继续下一个玩家
  3. 如果所有玩家都跳过，返回 `ResponseWindowResult(State: NoResponse)`

- **结束条件**：
  - **无人响应**：所有玩家都跳过，返回 `NoResponse`
  - **有响应则生效**：第一个玩家成功响应后，立即返回 `ResponseSuccess`，不再询问后续玩家

- **代码组织**：
  - 将长循环拆分为多个私有方法：
    - `TryPollResponder`：尝试轮询单个玩家
    - `GetLegalResponseCards`：获取合法响应牌
    - `GetPlayerChoiceForResponse`：获取玩家选择
    - `ProcessPlayerResponse`：处理玩家响应
    - `TryMoveResponseCard`：尝试移动响应牌
    - `LogResponsePassed`、`LogResponseInvalid`、`LogResponseCardPlayed`：日志记录方法

### 5.2 响应顺序确定

- **初始实现**：
  - 对于【闪】响应【杀】：
    - 响应顺序为目标玩家（被杀的目标）
    - 如果目标玩家不响应，则结束（不支持其他玩家响应）
  - 对于【桃】响应濒死（预留，步骤 13）：
    - 响应顺序为按座次顺序的所有存活玩家（包括濒死玩家自己）

- **设计原则**：
  - 响应顺序由 `ResponseWindowContext.ResponderOrder` 提供
  - 响应顺序的确定逻辑可以在创建响应窗口时通过规则服务计算

---

## 6. 与 Resolution Pipeline 的集成

### 6.1 ResponseWindowResolver 作为 Resolver

- **设计**：
  - `ResponseWindowResolver` 实现 `IResolver` 接口
  - 可以推入 `IResolutionStack`，与其他 resolver 无缝集成

- **执行流程**：
  1. `ResponseWindowResolver.Resolve()` 被调用
  2. 创建 `ResponseWindowContext`，包含响应类型、响应顺序等信息
  3. 创建 `BasicResponseWindow` 并执行
  4. 等待玩家选择（通过 `ChoiceResult`，由上层引擎提供）
  5. 返回 `ResolutionResult`，表示响应窗口执行结果

### 6.2 与 SlashResolver 的集成（预留，步骤 12 实现）

- **当前状态**：
  - `SlashResolver` 目前直接假设杀命中，不触发响应窗口
  - 在步骤 12 中，`SlashResolver` 将修改为：在杀命中前推入 `ResponseWindowResolver`

- **预留接口**：
  - `ResponseWindowResolver` 设计时考虑与 `SlashResolver` 的集成
  - 响应窗口执行完成后，根据结果决定是否触发伤害结算

---

## 7. 实现步骤

### 步骤 1：定义响应窗口抽象

- 在 `core/Response.Abstractions.cs` 中：
  - 定义 `IResponseWindow` 接口
  - 定义 `ResponseWindowContext` record
  - 定义 `ResponseOpportunity` record
  - 定义 `ResponseWindowResult` record 和 `ResponseWindowState` 枚举
  - 为上述类型添加 XML 注释

### 步骤 2：实现 BasicResponseWindow

- 在 `core/Response.Basic.cs` 中：
  - 实现 `BasicResponseWindow` 类，实现 `IResponseWindow` 接口
  - 实现轮询逻辑：按顺序询问玩家是否响应
  - 实现结束条件判断：无人响应/有响应则生效
  - 实现响应牌移动逻辑
  - 将长循环拆分为多个私有方法以提高可读性

### 步骤 3：实现 ResponseWindowResolver

- 在 `core/Response.Basic.cs` 中：
  - 实现 `ResponseWindowResolver` 类，实现 `IResolver` 接口
  - 将响应窗口作为 resolver 推入结算栈
  - 处理响应窗口的执行和结果返回

### 步骤 4：实现扩展方法

- 在 `core/Response.Extensions.cs` 中：
  - 实现 `CreateJinkResponseWindow` 扩展方法，用于在 Resolution Pipeline 中创建响应窗口
  - 实现 `CreateResponseWindow` 扩展方法，支持自定义响应窗口
  - 实现响应顺序计算的辅助方法：`CalculateJinkResponderOrder`、`CalculatePeachResponderOrder`

### 步骤 5：编写单元测试

- 在 `core.Tests/ResponseTests.cs` 中：
  - 测试响应窗口的轮询逻辑（按顺序询问玩家）
  - 测试无人响应的情况（所有玩家都跳过）
  - 测试有响应则生效的情况（第一个玩家成功响应）
  - 测试响应牌移动逻辑
  - 测试响应窗口作为 resolver 的集成
  - 测试扩展方法

---

## 8. 测试策略

### 8.1 单元测试覆盖

**BasicResponseWindow 测试**：
- 轮询顺序：验证按 `ResponderOrder` 顺序询问玩家
- 无人响应：所有玩家都跳过，返回 `NoResponse`
- 有响应则生效：第一个玩家成功响应后立即返回，不再询问后续玩家
- 响应牌移动：验证响应牌从手牌移动到弃牌堆
- 非法响应：玩家选择非法牌时返回错误

**ResponseWindowResolver 测试**：
- 作为 resolver 推入结算栈并执行
- 响应窗口执行完成后返回正确的 `ResolutionResult`

**集成测试**：
- 响应窗口与规则服务的集成（判断玩家是否有资格响应）
- 响应窗口与选择请求工厂的集成（创建选择请求）
- 响应窗口与牌移动服务的集成（移动响应牌）

### 8.2 测试数据准备

- 创建最小游戏状态：2-4 个玩家，初始手牌包含【闪】
- 模拟响应场景：玩家 A 对玩家 B 出杀，玩家 B 可以选择响应【闪】
- 验证响应窗口执行后的游戏状态（响应牌是否移动、响应结果是否正确）

---

## 9. 后续扩展点

本实现为以下功能预留了扩展点：

1. **完善 Slash + Jink 流程**（步骤 12）：
   - `SlashResolver` 在杀命中前推入 `ResponseWindowResolver`
   - 响应窗口执行完成后，根据结果决定是否触发伤害结算

2. **濒死流程**（步骤 13）：
   - 濒死救援使用响应系统，轮询所有存活玩家是否打出【桃】

3. **复杂响应链**（步骤 12 之后）：
   - 支持追击机制（如【青龙偃月刀】在杀被闪后触发追加出杀窗口）
   - 支持替换响应、取消响应等复杂机制

4. **事件总线集成**（步骤 14）：
   - 响应窗口在关键节点发布事件（如 `ResponseWindowOpened`、`ResponseCardPlayed`、`ResponseWindowClosed`）
   - 技能可以订阅这些事件并介入响应流程

5. **技能介入**（步骤 16）：
   - 技能可以修改响应顺序、响应资格、可用响应牌等

---

## 10. 注意事项

1. **玩家选择等待**：
   - 响应窗口需要等待玩家选择（通过 `ChoiceResult`）
   - 当前实现假设上层引擎负责等待玩家选择并提供 `ChoiceResult`
   - 未来可能需要支持异步/回调机制

2. **响应顺序计算**：
   - 响应顺序的确定逻辑可以在创建响应窗口时通过规则服务计算
   - 不同响应类型可能有不同的响应顺序规则

3. **状态修改的原子性**：
   - 响应窗口执行过程中可能修改游戏状态（如打出响应牌）
   - 如果响应窗口执行失败，需要考虑状态回滚（当前实现暂不考虑，后续可能需要）

4. **与 SlashResolver 的集成时机**：
   - 当前 `SlashResolver` 不触发响应窗口，直接假设杀命中
   - 在步骤 12 中，`SlashResolver` 将修改为触发响应窗口
   - 本步骤只提供响应系统骨架，不修改 `SlashResolver`

5. **日志记录**：
   - 如果提供了 `ILogSink`，响应窗口应记录关键事件（如响应窗口开启、玩家响应、响应窗口关闭）
   - 日志条目应包含响应类型、响应玩家、响应牌等信息

6. **代码组织**：
   - 将长循环拆分为多个私有方法，提高代码可读性和可维护性
   - 每个方法职责单一，便于测试和调试

---

## 11. 完成定义（Definition of Done）

- **结构与接口**：
  - `LegendOfThreeKingdoms.Core.Response` 命名空间中的接口与 DTO 定义完整，通过编译，并具备清晰 XML 注释

- **功能实现**：
  - `BasicResponseWindow` 能够正确执行轮询逻辑，按顺序询问玩家是否响应
  - `BasicResponseWindow` 能够正确处理两种结束条件：无人响应/有响应则生效
  - `ResponseWindowResolver` 能够作为 resolver 推入结算栈并执行
  - 响应牌能够正确从手牌移动到弃牌堆
  - 代码组织良好，长循环已拆分为多个私有方法

- **集成与测试**：
  - 响应窗口与规则服务、选择请求工厂、牌移动服务正确集成
  - 新增针对响应窗口的单元测试覆盖至少：
    - 轮询顺序正确
    - 无人响应的情况
    - 有响应则生效的情况
    - 响应牌移动逻辑
    - 响应窗口作为 resolver 的集成
  - 现有测试（如 `ResolutionTests`）全部通过
  - 确认在固定 seed 和相同选择序列下，响应窗口执行结果完全确定

- **文档**：
  - 本 `PLAN.md` 已与其它 `*_PLAN.md` 文档在命名与职责划分上保持一致，并在必要位置添加交叉引用











