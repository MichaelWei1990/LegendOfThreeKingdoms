# 三国杀 Core 最小 Resolution Pipeline：UseCard & Slash 技术规划（PLAN）

> 聚焦于 `core_module_breakdown.md` 中的 **9. 最小 Resolution Pipeline：UseCard & Slash**，在已有 **规则服务（Rules）**、**动作与选择层（Actions）** 以及 **牌移动服务（Zones）** 基础上，设计并实现最小结算管线，包括：resolver 抽象接口、`UseCardResolver` 和 `SlashResolver`，实现从"出杀"到"杀命中"的最小闭环。**注意**：伤害结算（`DamageResolver`）属于第10步，不在本计划范围内。

---

## 1. 范围与目标

- **范围（Scope）**
  - 在 `core` Class Library 中引入 **Resolution Pipeline（结算管线）** 抽象层：
    - 定义核心 resolver 接口：`IResolver`、`ResolutionContext`、`ResolutionStack` 等。
    - 实现 `UseCardResolver`：处理"使用牌"的通用流程（检查合法性、确定目标、移动牌）。
    - 实现 `SlashResolver`：处理【杀】的特殊结算流程（命中判断，暂不实现响应链）。
  - 约束：
    - **暂不引入响应链轮询**：先不实现【闪】的响应窗口，`SlashResolver` 直接假设"杀命中"。
    - **不实现伤害结算**：`DamageResolver` 属于第10步，不在本计划范围内。`SlashResolver` 在确认命中后返回成功，伤害结算由后续模块处理。
    - **不依赖事件总线**：先不引入全局事件系统，但为未来事件发布预留接口。

- **目标（Goals）**
  - **可插拔设计**：resolver 通过接口注册，便于后续扩展（如锦囊牌、装备牌等）。
  - **状态驱动**：resolver 直接修改 `Game` 状态（牌移动），与规则层的"只读判断"形成清晰分工。
  - **可追踪**：通过 `ResolutionStack` 记录结算过程，便于调试与日志记录。
  - **可测试**：通过单元测试覆盖"出杀 → 选目标 → 结算 → 杀命中"的完整路径。

- **非目标（Non-Goals）**
  - 不实现响应链系统（【闪】的响应窗口将在后续模块实现）。
  - 不实现伤害结算（`DamageResolver` 属于第10步，将在后续模块实现）。
  - 不实现复杂技能介入（技能系统将在后续模块实现）。
  - 不实现完整事件总线（事件系统将在后续模块实现）。
  - 不实现濒死与救援流程（将在后续模块实现）。

---

## 2. 与现有模块的关系

### 2.1 上游依赖

- **规则服务层**（见 `02.04_BasicRuleServicesAndQueries_PLAN.md`）
  - `IRuleService` / `ICardUsageRuleService`：resolver 在执行前调用规则服务进行最终合法性校验。
  - `RuleContext` / `CardUsageContext`：resolver 接收来自规则层的上下文信息。

- **动作与选择层**（见 `02.05_ActionAndChoiceDescriptors_PLAN.md`）
  - `ActionDescriptor` / `ChoiceResult`：resolver 通过 `IActionResolutionMapper` 接收动作描述和玩家选择。
  - `IActionResolutionMapper`：将动作映射到具体 resolver 调用（例如 `UseSlash` → `SlashResolver`）。

- **牌移动服务**（见 `02.08_CardMoveAndZones_PLAN.md`）
  - `ICardMoveService`：resolver 使用牌移动服务将牌从手牌移动到弃牌堆。
  - `CardMoveReason.Play`：标记"打出牌"的移动原因。

- **模型层**
  - `Game` / `Player` / `Card`：resolver 直接修改这些模型的状态（如牌移动）。

### 2.2 下游被依赖方

- **伤害结算系统**（未来，见 `core_module_breakdown.md` 第10步）
  - `SlashResolver` 在确认"杀命中"后，将由 `DamageResolver` 处理伤害结算（扣减体力、记录伤害事件）。

- **响应链系统**（未来，见 `core_module_breakdown.md` 第11-12步）
  - `SlashResolver` 在后续版本中将触发响应窗口，允许目标玩家打出【闪】。

- **事件总线与技能引擎**（未来，见 `core_module_breakdown.md` 第14-16步）
  - resolver 在关键节点发布事件（如 `CardUsed`、`DamageCreated`），供技能系统订阅和介入。

- **日志与回放系统**（未来，见 `core_module_breakdown.md` 第17-18步）
  - `ResolutionStack` 记录的信息将用于生成结构化日志和回放记录。

---

## 3. 命名空间与文件布局建议

- **命名空间**
  - 引入新的功能命名空间：`LegendOfThreeKingdoms.Core.Resolution`：
    - 专注于"结算管线"的核心抽象与实现。
    - 依赖 `LegendOfThreeKingdoms.Core.Model`、`LegendOfThreeKingdoms.Core.Rules`、`LegendOfThreeKingdoms.Core.Zones`，不反向依赖 `Turns` / `Actions`（通过接口解耦）。

- **文件结构建议**
  - `core/Resolution.Abstractions.cs`：
    - `IResolver`：核心 resolver 接口。
    - `ResolutionContext`：结算上下文（包含 `Game`、当前玩家、动作描述等）。
    - `IResolutionStack`：结算栈接口（记录当前活跃的 resolver 链）。
    - `ResolutionResult`：结算结果（成功/失败、错误信息等）。
    - `ResolutionRecord`：结算记录（用于历史追踪）。
  - `core/Resolution.Basic.cs`：
    - `UseCardResolver`：通用"使用牌" resolver。
    - `SlashResolver`：【杀】的专用 resolver。
    - `BasicResolutionStack`：基础结算栈实现。
  - `core/Resolution.Extensions.cs`：
    - `ResolutionExtensions`：扩展方法，用于注册 resolver handler 到 `ActionResolutionMapper`。
  - 后续可选：`core/Resolution.Events.cs`（若事件相关 DTO 较多时拆分）。

> 命名风格与 `GameSetup.Abstractions.cs` / `GameSetup.Basic.cs`、`Zones.Abstractions.cs` / `Zones.Basic.cs` 保持一致。

---

## 4. 核心抽象与数据结构

### 4.1 IResolver 接口

- **职责**：定义单个 resolver 的执行契约。
- **核心方法**：
  - `ResolutionResult Resolve(ResolutionContext context)`：
    - 接收结算上下文，执行结算逻辑，返回结果。
    - resolver 内部可以：
      - 调用规则服务进行合法性校验。
      - 使用牌移动服务移动牌。
      - 修改 `Game` / `Player` 状态（如牌移动）。
      - 创建并推入新的 resolver 到结算栈（如 `UseCardResolver` → `SlashResolver`）。

### 4.2 ResolutionContext（结算上下文）

- **字段示意**：
  - `Game Game`：当前对局状态（可变，resolver 可修改）。
  - `Player SourcePlayer`：发起结算的玩家（如出杀的玩家）。
  - `ActionDescriptor? Action`：触发结算的动作描述（可选，某些 resolver 可能由其他 resolver 内部创建）。
  - `ChoiceResult? Choice`：玩家选择（目标、牌等）。
  - `IResolutionStack Stack`：当前结算栈（resolver 可推入新的 resolver）。
  - `ICardMoveService CardMoveService`：牌移动服务（依赖注入）。
  - `IRuleService RuleService`：规则服务（依赖注入，用于最终校验）。

- **设计原则**：
  - 上下文对象在 resolver 之间传递，包含执行结算所需的所有依赖。
  - 上下文中的 `Game` 是可变的，resolver 直接修改状态。

### 4.3 IResolutionStack（结算栈接口）

- **职责**：管理当前活跃的 resolver 链，支持嵌套结算（如"使用杀" → "造成伤害" → "触发技能"）。
- **核心方法**：
  - `void Push(IResolver resolver, ResolutionContext context)`：推入新的 resolver。
  - `ResolutionResult Pop()`：弹出并执行当前 resolver，返回结果。
  - `IReadOnlyList<ResolutionRecord> GetHistory()`：获取已完成的结算历史（用于调试和日志）。
  - `bool IsEmpty { get; }`：检查栈是否为空。

- **ResolutionRecord（结算记录）**：
  - 字段：`Type ResolverType`、`ResolutionContext ContextSnapshot`、`ResolutionResult Result`。
  - 用于记录每次 resolver 的执行情况。

### 4.4 ResolutionResult（结算结果）

- **字段示意**：
  - `bool Success`：结算是否成功。
  - `ResolutionErrorCode? ErrorCode`：错误码（如 `InvalidTarget`、`CardNotFound`）。
  - `string? MessageKey`：错误消息键（用于本地化）。
  - `object? Details`：额外详情（用于调试）。

- **设计原则**：
  - resolver 返回结果后，调用方（如 `IActionResolutionMapper`）根据结果决定后续流程。

---

## 5. Resolver 实现设计

### 5.1 UseCardResolver（通用使用牌 Resolver）

- **职责**：
  - 接收"使用牌"的动作和选择，执行通用流程：
    1. 从 `ChoiceResult` 中提取选中的牌和目标。
    2. 使用 `IRuleService.ValidateActionBeforeResolve` 进行最终合法性校验。
    3. 使用 `ICardMoveService` 将牌从手牌移动到弃牌堆（`CardMoveReason.Play`）。
    4. 根据牌的类型，推入对应的专用 resolver（如 `SlashResolver`）到结算栈。

- **输入**：
  - `ActionDescriptor`：`ActionId = "UseSlash"` 或 `"UsePeach"`。
  - `ChoiceResult`：包含 `SelectedCardIds` 和 `SelectedTargetSeats`。

- **输出**：
  - 成功：推入 `SlashResolver` 或 `PeachResolver`（后者暂不实现）。
  - 失败：返回 `ResolutionResult` 包含错误信息。

### 5.2 SlashResolver（杀 Resolver）

- **职责**：
  - 处理【杀】的特殊结算：
    1. 从上下文提取目标玩家。
    2. **暂不实现响应链**：直接假设"杀命中"（后续模块将引入【闪】的响应窗口）。
    3. **暂不实现伤害结算**：`DamageResolver` 属于第10步，不在本计划范围内。`SlashResolver` 在确认命中后返回成功，表示"杀已命中目标"。

- **输入**：
  - 由 `UseCardResolver` 推入，上下文包含已使用的【杀】牌和目标玩家。

- **输出**：
  - 成功：返回 `ResolutionResult.Success`，表示"杀已命中"（伤害结算由后续 `DamageResolver` 处理）。
  - 失败：返回错误（如目标已死亡）。

> **注意**：虽然 `core_module_breakdown.md` 第9步的描述中提到"杀命中 → 造成伤害 → 扣减体力"，但实现上，第9步只负责到"杀命中"这一步。伤害结算（`DamageResolver`）属于第10步，将在后续计划中实现。

---

## 6. 与 IActionResolutionMapper 的集成

- **当前状态**（见 `core/Actions.Mapping.cs`）：
  - `ActionResolutionMapper` 维护 `actionId → ActionHandler` 的映射表。
  - `ActionHandler` 委托接收 `RuleContext`、`ActionDescriptor`、`ChoiceResult`。

- **集成方式**：
  1. 在 `ActionResolutionMapper` 的注册阶段（如 `GameEngine` 初始化时）：
     - 为 `"UseSlash"` 注册 handler，handler 内部创建 `ResolutionContext` 并调用 `UseCardResolver.Resolve()`。
  2. `UseCardResolver` 执行后：
     - 如果成功，会推入 `SlashResolver` 到结算栈。
     - 结算栈负责依次执行所有 resolver，直到栈为空或某个 resolver 返回失败。
  3. `SlashResolver` 执行后：
     - 确认"杀命中"后返回成功。
     - 伤害结算将由后续的 `DamageResolver`（第10步）处理，不在本计划范围内。
  4. 最终结果：
     - 通过 `IResolutionStack` 的 `GetHistory()` 获取完整结算记录，返回给调用方。

---

## 7. 算法与流程示例

### 7.1 典型流程：出杀 → 杀命中

1. **玩家选择动作**：
   - UI/调用方调用 `IRuleService.GetAvailableActions()`，获得 `ActionDescriptor(ActionId: "UseSlash", ...)`。
   - 玩家选择目标和牌，生成 `ChoiceResult`。

2. **进入 Resolution Pipeline**：
   - `IActionResolutionMapper.Resolve()` 被调用，查找 `"UseSlash"` 的 handler。
   - Handler 创建 `ResolutionContext`（包含 `Game`、`SourcePlayer`、`Action`、`Choice`、`Stack`、服务依赖）。
   - Handler 创建 `UseCardResolver` 并推入结算栈。

3. **UseCardResolver 执行**（由结算栈驱动）：
   - 从 `ChoiceResult` 提取 `SelectedCardIds[0]` 和 `SelectedTargetSeats[0]`。
   - 调用 `IRuleService.ValidateActionBeforeResolve()` 进行最终校验。
   - 调用 `ICardMoveService.DiscardFromHand()` 将【杀】从手牌移动到弃牌堆。
   - 创建 `SlashResolver` 并推入结算栈：`stack.Push(new SlashResolver(), context)`。

4. **SlashResolver 执行**（由结算栈驱动）：
   - 从上下文提取目标玩家。
   - **暂不实现响应链**：直接假设命中。
   - 返回 `ResolutionResult.Success`，表示"杀已命中目标"。

5. **结算完成**（第9步范围结束）：
   - 结算栈为空，返回最终结果给调用方。
   - 调用方可以查询 `IResolutionStack.GetHistory()` 获取完整结算记录。
   - **注意**：伤害结算（扣减体力）将由后续的 `DamageResolver`（第10步）处理，不在本计划范围内。

### 7.2 错误处理策略

- **规则校验失败**：
  - `UseCardResolver` 在调用 `ValidateActionBeforeResolve()` 时，如果返回 `RuleResult.Disallowed`，则返回 `ResolutionResult` 包含错误信息，不修改游戏状态。

- **牌移动失败**：
  - 如果 `ICardMoveService` 抛出异常（如牌不在手牌中），resolver 捕获异常并返回错误结果。

- **目标无效**：
  - `SlashResolver` 检查目标是否存活，如果已死亡则返回错误。

---

## 8. 分阶段实现计划

### 阶段 1：接口与抽象骨架

- **目标**：在不修改现有逻辑的前提下，引入 resolver 相关接口与数据结构。
- **工作项**：
  1. 在 `LegendOfThreeKingdoms.Core.Resolution` 命名空间中新建 `Resolution.Abstractions.cs`：
     - 定义 `IResolver` 接口。
     - 定义 `ResolutionContext` record。
     - 定义 `IResolutionStack` 接口和 `ResolutionRecord` / `ResolutionResult`。
  2. 为上述类型添加 XML 注释，明确与 `Rules` / `Actions` / `Zones` 的边界。
  3. 编写接口级的最小编译测试（例如只构造空实现）。

### 阶段 2：BasicResolutionStack 实现

- **目标**：完成最小可用的结算栈实现。
- **工作项**：
  1. 在 `Resolution.Basic.cs` 中实现 `BasicResolutionStack`：
     - 维护内部 resolver 队列/栈结构。
     - 实现 `Push()` / `Pop()` 方法。
     - 实现 `GetHistory()` 方法，记录每次 resolver 的执行情况。
  2. 编写单元测试：
     - 测试推入/弹出 resolver 的顺序。
     - 测试历史记录的完整性。

### 阶段 3：UseCardResolver 实现

- **目标**：实现通用"使用牌" resolver，能够处理【杀】的基础流程。
- **工作项**：
  1. 在 `Resolution.Basic.cs` 中实现 `UseCardResolver`：
     - 从 `ChoiceResult` 提取牌和目标。
     - 调用规则服务进行最终校验。
     - 使用牌移动服务将牌移动到弃牌堆。
     - 根据牌类型推入对应的专用 resolver（如 `SlashResolver`）。
  2. 编写单元测试：
     - 测试合法出杀的完整流程（到推入 `SlashResolver` 为止）。
     - 测试规则校验失败的情况。
     - 测试牌移动失败的情况。

### 阶段 4：SlashResolver 实现

- **目标**：实现【杀】的结算流程，从出杀到确认命中。
- **工作项**：
  1. 在 `Resolution.Basic.cs` 中实现 `SlashResolver`：
     - 提取目标玩家。
     - 暂不实现响应链，直接假设命中。
     - 返回 `ResolutionResult.Success`，表示"杀已命中"。
  2. 编写单元测试：
     - 测试完整流程：出杀 → 选目标 → 结算 → 确认命中。
     - 测试目标死亡的情况。
     - **注意**：伤害结算（扣减体力）不在本阶段范围内，将由第10步的 `DamageResolver` 处理。

### 阶段 5：与 ActionResolutionMapper 集成

- **目标**：将 resolver 系统接入现有的动作执行流程。
- **工作项**：
  1. 在 `Resolution.Extensions.cs` 中创建扩展方法：
     - 实现 `RegisterUseSlashHandler` 扩展方法，用于注册 `"UseSlash"` 的 handler。
     - Handler 创建 `ResolutionContext` 并调用 `UseCardResolver.Resolve()`。
     - Handler 负责驱动结算栈，依次执行所有 resolver。
  2. 调整现有测试：
     - 确保 `TurnEngineTests` 等现有测试仍能通过。
     - 添加集成测试：从 `GetAvailableActions()` → `Resolve()` → 验证游戏状态变化。

---

## 9. 设计约束与最佳实践

- **与规则层解耦**
  - resolver 依赖规则服务进行校验，但不反向依赖：规则服务不知道 resolver 的存在。

- **状态修改的明确性**
  - resolver 直接修改 `Game` / `Player` 状态，与规则层的"只读判断"形成清晰分工。
  - 所有状态修改都通过 resolver 进行，避免在 `TurnEngine` 或其他模块中直接修改。

- **错误尽量早暴露**
  - resolver 在执行前进行充分校验，避免部分修改状态后才发现错误。

- **为响应链和事件系统预留扩展点**
  - `SlashResolver` 中预留"响应窗口"的接口（即使暂不实现）。
  - 为后续 `DamageResolver`（第10步）预留扩展点，确保 `SlashResolver` 的输出能够被 `DamageResolver` 消费。

- **保持确定性**
  - resolver 的执行结果必须完全确定，不依赖外部状态（如 `DateTime.Now`）。

---

## 10. 完成定义（Definition of Done）

- **结构与接口**：
  - `LegendOfThreeKingdoms.Core.Resolution` 命名空间中的接口与 DTO 定义完整，通过编译，并具备清晰 XML 注释。

- **功能实现**：
  - `BasicResolutionStack` 能够正确管理 resolver 链，记录执行历史。
  - `UseCardResolver` 能够：
    - 校验合法性、移动牌、推入专用 resolver。
  - `SlashResolver` 能够：
    - 处理【杀】的结算，确认"杀命中"并返回成功。

- **集成与测试**：
  - `ActionResolutionMapper` 已注册 `"UseSlash"` 的 handler，能够驱动完整结算流程。
  - 新增针对 resolver 的单元测试覆盖至少：
    - 合法出杀的完整流程（到确认命中为止）。
    - 规则校验失败的情况。
    - 目标死亡的情况。
  - 现有测试（如 `TurnEngineTests`）全部通过。
  - 确认在固定 seed 和相同选择序列下，结算结果完全确定。
