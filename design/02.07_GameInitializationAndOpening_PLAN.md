# 三国杀 Core 对局初始化与开局流程技术规划（PLAN）

> 聚焦于 `core_module_breakdown.md` 中的 **7. 对局初始化与开局流程**，在已有 **模型层（Game/Player/Card/Zone）**、**枚举与基础类型** 以及 **回合/阶段引擎** 基础上，定义从“配置 + 随机源”构建一个完整可用初始 `Game` 状态的流程，包括：牌堆构建与洗牌、座位与武将分配、初始手牌发放与首回合起始状态。

---

## 1. 范围与目标

- **范围（Scope）**  
  - 在 `core` Class Library 中实现一个**纯后端、与 UI 无关**的对局初始化模块，负责：
    - 从 `GameConfig` / `PlayerConfig` 等配置对象创建 `Game` 实例；
    - 构建基础牌堆（仅主包基础牌即可）并执行洗牌；
    - 为每个玩家分配座位（seat）、阵营（如需要）和武将占位（即使暂不加载技能实现）；
    - 发放初始手牌（固定张数，可通过配置控制）；
    - 将 `Game` 状态推进到**可以进入首个玩家准备阶段**的状态（与 `TurnEngine` 对接）。

- **目标（Goals）**
  - **确定性**：在给定 `GameConfig` 与 `IRandomSource`（含种子）下，对局初始化过程是完全确定的，可用于回放与调试。
  - **可组合**：初始化逻辑与 `TurnEngine`、规则层、动作层解耦，通过清晰接口组合使用。
  - **可测试**：可通过单元测试构造不同配置与种子，断言生成的 `Game` 状态（牌堆顺序、初始手牌、首家座次等）。
  - **可扩展**：为未来加入扩展包、身份局（主忠内反）、特殊模式等预留扩展点，但首版只支持最简单“平民局/身份占位但无复杂规则”。

- **非目标（Non-Goals）**
  - 不实现复杂模式（如 3v3、军争、国战）与完整身份局胜负规则，仅关注“把一局牌开起来”。
  - 不在本模块内实现技能加载与触发逻辑，仅分配武将 ID/占位信息。
  - 不关心 UI/网络/存档格式，只维护内存 `Game` 状态。

---

## 2. 与现有模块的关系

### 2.1 上游依赖

- **配置与模型层**（见 `02.01_CoreFoundationAndConfiguration_PLAN.md`, `02.02_ModelLayerGamePlayerCardZone_PLAN.md`）
  - `GameConfig` / `PlayerConfig` / `DeckConfig`：定义玩家数量、初始手牌数、使用哪一组牌等。
  - `Game` / `Player` / `Zone`：初始化逻辑在这些模型上填充具体状态。
- **枚举与基础类型**（见 `02.03_EnumsAndBasicTypes_PLAN.md`）
  - `CardType`, `Suit`, `Camp`, `HeroId`（或类似武将标识）、`GameMode` 等。
- **随机源与日志接口**
  - `IRandomSource`：提供 `Next()` / `Shuffle` 等抽象，用于洗牌和随机分配。
  - `ILogSink`（如存在）：记录初始化过程中的关键事件（可选）。

### 2.2 下游被依赖方

- **Turn/Phase 引擎**（见 `02.06_TurnAndPhaseEngine_PLAN.md`）
  - 初始化完成后，调用 `ITurnEngine.InitializeTurnState(game)`，将状态切换到首回合准备阶段。
- **规则与动作层**
  - 初始手牌数量、首家选择等规则可部分由规则层提供（如未来存在变体），但首版可在初始化模块硬编码最基础规则。
- **日志与回放层**（未来）
  - 回放系统依赖“同样的 `GameConfig + seed + choiceSequence` 得到相同开局状态”，初始化模块是 determinism 的关键基础。

---

## 3. 命名空间与文件布局建议

- 推荐在 `core` 中新增/使用：
  - `LegendOfThreeKingdoms.Core.GameSetup`：对局初始化相关入口与服务
    - `IGameInitializer`：对局初始化接口
    - `GameInitializationResult`：初始化结果 DTO
  - 若需要进一步拆分，可引入内部命名空间：
    - `LegendOfThreeKingdoms.Core.GameSetup.Internal`：内部 helper，如牌堆构建器、武将分配器等（不对外暴露）。

- 典型文件结构示意（非强制）：
  - `core/GameSetup.Abstractions.cs`：`IGameInitializer`, `GameInitializationOptions`, `GameInitializationResult` 等接口/DTO。
  - `core/GameSetup.Basic.cs`：`BasicGameInitializer` 的基础实现。

> 与 `LegendOfThreeKingdoms.Core.Turns`、`LegendOfThreeKingdoms.Core.Rules`、`LegendOfThreeKingdoms.Core.Actions` 保持解耦：本模块只负责“初始状态构建”，不驱动后续回合与结算。

---

## 4. 对局配置与输入模型

- **输入对象设计（只描述语义，不写具体签名）**
  - `GameInitializationOptions`
    - 包含：
      - `GameConfig GameConfig`：对局全局配置（玩家数量、模式、初始手牌数等）。
      - `IReadOnlyList<PlayerConfig> Players`：每个玩家的初始配置（玩家 ID、是否为 AI、本地/远端等）。
      - `IRandomSource Random`：随机源；要求在外部注入，以支持回放。
      - 可选：`IHeroPool HeroPool`：提供可选武将集合（若尚未实现，可用简单列表替代）。
      - 可选：是否使用固定预设牌堆顺序（用于测试）。

- **与既有配置的关系**
  - 若 `GameConfig` 已在其他 PLAN 中定义初始化所需信息，则本模块仅组合使用；
  - 若缺少：
    - 需要在 `GameConfig` 中补充：
      - `InitialHandCardCount`（默认 4 张或其他规则）；
      - `UseIdentities`（是否启用身份局）；
      - `DeckDefinitionId` 或类似字段，用于选择具体牌堆构成策略。

---

## 5. 牌堆构建与洗牌算法

- **牌堆构建策略**
  - 定义一个内部/可替换的 `IDeckBuilder` 抽象或简单函数：
    - 输入：`DeckConfig` / `GameConfig`；
    - 输出：一组 `Card` 或 `CardId` 列表，按“逻辑顺序”构建（未洗牌）。
  - 首版实现：
    - 使用固定的主包基础牌集合（【杀】、【闪】、【桃】以及若干简单锦囊/装备）。
    - 暂不支持扩展包开关与复杂过滤条件，但在 `DeckConfig` 中预留可能的开关字段。

- **洗牌算法**
  - 要求：
    - 使用 `IRandomSource` 提供的随机数接口实现 Fisher–Yates 洗牌（或等价算法）。
    - 保证对于同一 `seed` 和同一初始牌列，洗牌结果完全一致。
  - 设计建议：
    - 在 `IRandomSource` 中提供 `Shuffle<T>(IList<T>)` 辅助方法，或在 `GameSetup` 内部实现一个基于 `IRandomSource.Next()` 的泛型洗牌 utility。

- **牌堆与 Zone 的接入**
  - 洗牌完成后，将牌列表填入 `Game` 的牌堆 `Zone`（如 `DeckZone`）。
  - 弃牌堆、移出游戏区等 Zone 在初始化时应为空，但保证结构已创建。

---

## 6. 玩家座位、武将与初始状态分配

- **座位与出牌顺序**
  - 默认规则：
    - 使用 `IRandomSource` 对玩家列表进行一次随机打乱，或根据配置决定是否“顺序座位 + 随机首家”。
    - 将结果映射为 `SeatIndex`（0..N-1），记录在 `Player` 中或独立结构。
  - 可选扩展点：
    - 支持外部传入固定座位顺序（用于重放或自定义房间）。

- **身份与阵营（如启用）**
  - 若 `GameMode` 为身份局：
    - 根据模式确定各身份数量（主、公忠、内、反）；
    - 使用 `IRandomSource` 为各座位随机分配身份；
    - 在 `Player` 或独立字段上存储身份/阵营信息。
  - 若为简单平民局：
    - 所有玩家身份/阵营相同或标记为 `None`，仅保留占位字段以便未来扩展。

- **武将分配**
  - 简化版策略：
    - 为每个座位分配一个固定武将 ID（由 `HeroPool` 或配置列表指定），不实现“选将”流程；
    - 或者：如果 `HeroPool` 提供的武将数 ≥ 玩家数：
      - 使用 `IRandomSource` 对武将列表洗牌后，按座位顺序分配前 N 个；
  - 武将技能实现不在本 PLAN 范围内，但需要：
    - 把武将 ID/元数据记录在 `Player` 对象中；
    - 为未来的技能加载器提供关联点（如 `HeroId` → `SkillRegistry`）。

- **初始体力与手牌上限**
  - 根据武将信息或模式规则（首版可硬编码）：
    - `MaxHealth` / `CurrentHealth` 初始化；
    - 初始手牌上限 = `MaxHealth` 或配置中的独立字段。

---

## 7. 对局初始化 API 设计

- **核心接口：`IGameInitializer`**
  - 典型职责：
    - 接收 `GameInitializationOptions`；
    - 构建 `Game` 实例与全部玩家对象；
    - 初始化牌堆/弃牌堆/其他 Zone；
    - 完成座位、身份、武将与初始手牌分配；
    - 调用 `ITurnEngine.InitializeTurnState(game)` 使 `Game` 处于首回合准备阶段；
    - 返回 `GameInitializationResult`。

- **`GameInitializationResult` 结构**
  - 字段示意：
    - `Game Game`：初始化完成的对局状态。
    - `bool Success`：初始化是否成功。
    - `string? ErrorCode` / `string? ErrorMessage`：如玩家数不合法、配置缺失等。
    - 可选：`IReadOnlyList<string> Warnings`：非致命问题（如某扩展包不可用）。

- **错误处理策略**
  - 对于配置错误（玩家数不在支持范围、缺少武将等）：
    - 默认返回 `Success = false` + 错误信息，而不是抛出异常；
    - 在测试中验证这些路径。
  - 对于编程错误或内部不变量破坏：
    - 可使用异常（例如 `InvalidOperationException`），但保持边界清晰。

---

## 8. 典型流程示例

- **从配置到可开局 Game 状态**
  1. 上层构造 `GameConfig` / `PlayerConfig` 列表，选择 `GameMode`、初始手牌数等；
  2. 上层创建 `IRandomSource`，指定种子（如 `seed = 123456`）；
  3. 构造 `GameInitializationOptions` 并调用 `IGameInitializer.Initialize(options)`；
  4. 初始化器内部：
     - 构建 `Game`、`Player` 对象，建立玩家与座位映射；
     - 调用 `IDeckBuilder` 构建初始牌堆并使用 `IRandomSource` 洗牌；
     - 根据模式与 `HeroPool` 为每位玩家分配武将与身份；
     - 按顺序为每个玩家从牌堆摸取初始手牌；
     - 调用 `ITurnEngine.InitializeTurnState(game)`，设置首家与 `TurnNumber = 1`, `CurrentPhase = Prepare`；
  5. 返回 `GameInitializationResult`，上层持有 `Game` 实例并开始回合驱动与玩家交互。

- **与回放的结合（未来）**
  - 在回放模式下：
    - 通过记录的 `ReplayRecord` 提取 `GameConfig` 与 `seed`；
    - 使用同一个 `IGameInitializer` 重建初始 `Game`；
    - 随后按 `choiceSequence` 重放玩家决策即可达到完全一致的对局过程。

---

## 9. 分阶段实现计划

### 阶段 1：输入/输出模型与接口骨架

- **目标**：定义 `IGameInitializer` 接口、`GameInitializationOptions` 与 `GameInitializationResult` 等 DTO，不写具体逻辑。
- **工作项**：
  1. 在 `LegendOfThreeKingdoms.Core.GameSetup` 命名空间中定义上述类型；
  2. 根据需要补充/调整 `GameConfig` / `PlayerConfig` / `DeckConfig` 字段，使其能承载初始化所需信息；
  3. 为接口与 DTO 编写基础构造/序列化单元测试，确保类型关系清晰。

### 阶段 2：牌堆构建与洗牌

- **目标**：能够在给定 `DeckConfig + IRandomSource` 下构建并洗好一副牌堆，并写入 `Game` 的牌堆 Zone。
- **工作项**：
  1. 实现最小版 `IDeckBuilder` 或等价内部方法，返回一组 `Card`/`CardId`；
  2. 基于 `IRandomSource` 实现 Fisher–Yates 洗牌；
  3. 将洗牌结果写入 `Game` 的牌堆 Zone，保证弃牌堆/其他 Zone 初始化为空；
  4. 编写单元测试：在固定 seed 下断言牌堆顺序 deterministic。

### 阶段 3：玩家与武将/身份分配 + 初始手牌

- **目标**：在 `Game` 中填充完整玩家状态并发放初始手牌。
- **工作项**：
  1. 依据配置与 `IRandomSource` 确定座位顺序与出牌顺序；
  2. 为每个玩家分配身份/阵营（若启用），并记录在模型中；
  3. 使用 `HeroPool` 或配置为每位玩家分配武将 ID；
  4. 从牌堆按顺序为每位玩家发放初始手牌，更新相应 Zone；
  5. 为 `MaxHealth` / `CurrentHealth` 与手牌上限赋初值；
  6. 为以上逻辑编写单元测试（如玩家数 2/3/4、固定种子下的武将/手牌分布）。

### 阶段 4：集成 TurnEngine 与错误处理

- **目标**：打通完整 `Initialize` 流程并处理配置错误等情况。
- **工作项**：
  1. 在初始化完成后调用 `ITurnEngine.InitializeTurnState(game)`，验证首回合玩家与阶段正确；
  2. 在配置不合法（如玩家数不在支持范围）时返回失败 `GameInitializationResult`；
  3. 添加集成测试：从 `GameConfig` → `GameInitializationResult` → 调用少量 `AdvancePhase`，验证结果路径与预期一致。

---

## 10. 设计约束与最佳实践

- **纯粹性与可测性**  
  - 初始化器不依赖任何 UI/网络/时间源（`DateTime.Now` 等），所有不确定性来自注入的 `IRandomSource`。
- **幂等性与不可变输入**  
  - 对于同一份配置和种子，多次调用应获得结构等价的初始 `Game` 状态；
  - 尽量避免在 `GameConfig` / `PlayerConfig` 上做就地修改。
- **扩展能力**  
  - 在接口层预留扩展：支持多种 `GameMode`、不同牌池、特殊开局规则，但首版实现只覆盖最基础常规模式。
- **与其它模块解耦**  
  - 初始化模块只依赖模型层与基础配置，不直接调用 Rules/Actions/Resolvers（除非极简 helper），避免循环依赖。

---

## 11. 完成定义（Definition of Done）

- **结构与接口**：
  - `LegendOfThreeKingdoms.Core.GameSetup` 命名空间中的接口与 DTO 定义完整，通过编译且有基础测试。
- **功能实现**：
  - `BasicGameInitializer`（或同等实现）能够在给定 `GameConfig + PlayerConfig[] + IRandomSource` 情况下：
    - 构建并洗好一副牌堆并写入 `Game`；
    - 为所有玩家分配座位、身份/阵营（如启用）、武将与初始体力；
    - 为每位玩家发放正确数量的初始手牌；
    - 调用 `ITurnEngine.InitializeTurnState(game)` 使游戏进入首回合准备阶段。
- **确定性与测试**：
  - 至少包含：
    - 不同玩家数下的初始化流程测试；
    - 固定 seed 下的 determinism 测试；
    - 配置不合法时的错误返回测试。
