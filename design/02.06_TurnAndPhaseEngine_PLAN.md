# 三国杀 Core Turn/Phase 状态与简单引擎技术规划（PLAN）

> 聚焦于 `core_module_breakdown.md` 中的 **6. Turn/Phase 状态与简单引擎**，在既有模型层与规则层、动作与 Choice 描述对象基础上，定义 **回合与阶段状态表示、最小回合状态机与推进接口**，形成一个不带技能/事件总线的“顺序驱动引擎”骨架。

---

## 1. 范围与目标

- **范围（Scope）**  
  - 在 `core` Class Library 中实现：
    - 回合与阶段相关的 **状态字段与模型结构**（包含在 `Game`/`Player` 或专门的 `TurnState` 类型中）。
    - 一个 **最小回合状态机**，支持基础主公局流程：
      - 准备 → 判定（可初期空实现）→ 摸牌 → 出牌 → 弃牌 → 结束。
    - 一组 **推进接口**，例如：
      - `InitializeTurnState()`, `StartNextTurn()`, `AdvancePhase()`, `EndCurrentPhaseIfPossible()`。
  - 仅实现“单线程、顺序推进”的最小引擎逻辑，不接入事件总线、不引入技能、不过度抽象复杂响应链。

- **目标（Goals）**
  - **可驱动**：在无 UI / 网络前提下，仅通过调用引擎 API 就能驱动一局游戏在玩家之间轮转回合与阶段。
  - **与规则层解耦**：引擎负责“谁的回合、当前处于哪个阶段、下一步能否推进”，具体“能不能出牌、能出哪些牌”仍由 `Rules`/`Actions` 层判断。
  - **可测试**：回合推进逻辑可通过单元测试验证（例如：从初始状态连续调用 `AdvancePhase()`，状态机路径与预期一致）。
  - **可扩展**：为未来加入额外阶段、子阶段、响应窗口、技能触发与事件总线预留插入点，但不在本阶段强制实现。

- **非目标（Non-Goals）**
  - 不实现完整的技能介入、响应链、复杂触发时机，只提供简单“顺序阶段流转”。
  - 不处理 UI、网络协议、日志与回放序列化，仅维护纯内存状态。
  - 不在本层直接修改牌区（摸牌/弃牌等）以外的复杂结算，复杂结算交给 Resolver 和 CardMove/Resolution 层。

---

## 2. 与现有模块的关系

### 2.1 上游依赖

- **模型层（Game / Player / Card / Zone）**
  - `Game`：
    - 玩家列表、当前回合玩家索引/ID。
    - 牌堆/弃牌堆、基础配置。
  - `Player`：
    - 体力状态、手牌/装备/判定区引用。
- **枚举与基础类型（Phase 等）**
  - `Phase`：至少包含 `Prepare`, `Judge`, `Draw`, `Play`, `Discard`, `End`。
- **规则层（Rules，见 `design/02.04_BasicRuleServicesAndQueries_PLAN.md`）**
  - 用于：
    - 在某阶段开始时计算当前玩家可执行的基础动作列表。
    - 验证“是否可以结束当前阶段”等操作的合法性。

### 2.2 下游被依赖方

- **动作与 Choice 层（Actions，见 `design/02.05_ActionAndChoiceDescriptors_PLAN.md`）**
  - 回合引擎在阶段内/阶段结束时，会通过 `IActionQueryService` 与 `ActionDescriptor` 驱动玩家行为。
- **Resolver 层与 CardMove 服务**
  - 在特定阶段（如摸牌阶段）调用简单的牌堆/手牌操作（如“从牌堆摸 N 张到当前玩家手牌”）。
- **事件总线与技能引擎（未来）**
  - 未来会在回合/阶段开始与结束点发布 `TurnStart/End`, `PhaseStart/End` 事件，供技能订阅。

---

## 3. 命名空间与文件布局建议

- `LegendOfThreeKingdoms.Core.Turns`：回合与阶段引擎根命名空间
  - `LegendOfThreeKingdoms.Core.Turns.Abstractions`：
    - 接口与核心 DTO：`ITurnEngine`, `TurnState`, `PhaseState`（如需要）、`TurnTransitionResult` 等。
  - `LegendOfThreeKingdoms.Core.Turns.Basic`：
    - 基础实现：`BasicTurnEngine`，实现标准的“准备 → 判定 → 摸牌 → 出牌 → 弃牌 → 结束”序列。
  - 可选：`LegendOfThreeKingdoms.Core.Turns.Internal`：
    - 内部辅助类型，如简单的状态机实现细节（若需要）。

> 与 `LegendOfThreeKingdoms.Core.Rules` 与 `LegendOfThreeKingdoms.Core.Actions` 命名空间保持分层清晰：Model → Rules → Actions → **Turns** → Resolvers / Response / EventBus。

---

## 4. 回合与阶段状态抽象设计

### 4.1 基础状态结构

- **`TurnState`**
  - 字段示意：
    - `CurrentPlayerId` 或 `CurrentSeatIndex`。
    - `TurnNumber`：当前是第几个回合（从 1 开始）。
    - `CurrentPhase`：当前大阶段（枚举 `Phase`）。
    - 可选：`SubPhase`：用于将来扩展判定子阶段、阶段内子步骤。
  - 职责：
    - 提供一个快照，代表“当前回合与阶段”的状态。

- **在 `Game` 中的集成方式**
  - `Game` 中新增字段：
    - `TurnState Turn` 或类似命名的 `CurrentTurn`。
  - 设计要求：
    - 回合/阶段状态始终由回合引擎维护，外部模块只读（或通过公开 API 修改）。

### 4.2 Phase 流程枚举与顺序

- 最小版本固定序列（无支线）：
  1. `Prepare`
  2. `Judge`（允许为空步骤）
  3. `Draw`
  4. `Play`
  5. `Discard`
  6. `End`
- 后续可扩展：
  - 如：加入特殊阶段（如觉醒阶段）、子阶段、回合外阶段等，通过扩展 `Phase` 枚举和编排规则实现。

---

## 5. Turn/Phase 引擎接口设计

### 5.1 ITurnEngine

- **核心职责**：
  - 初始化对局回合状态。
  - 推进回合与阶段。
  - 为上层提供只读访问当前 Turn/Phase 状态的接口。

- **典型方法语义（不写具体代码签名）**：
  - `InitializeTurnState(game)`：
    - 设置首个回合玩家（按座次或规则），`TurnNumber = 1`，`CurrentPhase = Prepare`。
  - `StartNextTurn(game)`：
    - 将当前玩家推进到下一位存活玩家；
    - `TurnNumber++`；
    - 将 `CurrentPhase` 重置为 `Prepare`。
  - `AdvancePhase(game)`：
    - 将当前 `Phase` 推进到下一个预定义阶段；
    - 若已在 `End` 阶段，则自动调用 `StartNextTurn()`。
  - `CanEndCurrentPhase(game)`：
    - 利用规则层判断当前阶段是否允许结束（例如出牌阶段仍有强制动作时不允许提前结束）。
  - `GetCurrentTurnState(game)`：
    - 返回当前回合状态的只读快照（用于日志/调试/测试）。

### 5.2 TurnTransitionResult

- 为每次推进返回结构化结果：
  - `IsSuccess`：是否成功推进。
  - `NewPhase` / `NewTurnNumber` / `NewCurrentPlayerId` 等。
  - `ErrorCode`：如 `NoAlivePlayers`, `PhaseCannotEndYet`。
  - 便于上层在测试和日志中检查每次状态变化。

---

## 6. 阶段逻辑与与其它模块协作

### 6.1 各阶段职责边界（最小版本）

- **Prepare Phase**
  - 功能：
    - 标记回合开始。
    - 未来挂载“回合开始”技能触发点。
  - 最小实现：
    - 当前可空实现，仅改变 `Phase` 即可。

- **Judge Phase**
  - 功能：
    - 处理判定区牌（如乐不思蜀、闪电）。
  - 最小实现：
    - 初期可空实现，保留阶段以简化未来扩展。

- **Draw Phase**
  - 功能：
    - 从牌堆摸固定数量的牌（如 2 张）。
  - 与其他模块协作：
    - 通过 CardMove 服务或简单牌堆 API：`DrawCards(game, player, count)`。
  - 最小实现：
    - 固定摸牌数，暂不考虑技能/装备修正。

- **Play Phase**
  - 功能：
    - 允许当前玩家执行各种动作（使用【杀】/【桃】等）。
  - 协作：
    - 通过 `IActionQueryService.GetAvailableActions(game, currentPlayer)` 获得可用动作列表；
    - 引擎自身不驱动每步动作，仅负责“阶段不变时保持停留在 Play 阶段”。

- **Discard Phase**
  - 功能：
    - 若手牌数 > 体力上限，则要求弃牌。
  - 最小实现：
    - 仅在结束前检查“手牌数 - 体力上限”，若需要弃牌，则通过 Actions/Choice 请求玩家选择弃牌（可留待后续阶段实现）；
    - 第一版可简化为：暂不强制实现弃牌逻辑，但至少保留阶段形态。

- **End Phase**
  - 功能：
    - 回合结束点；未来挂载“回合结束”技能触发。
  - 最小实现：
    - 仅通过 `AdvancePhase` 将状态推进到下一玩家的 `Prepare`。

### 6.2 回合内状态变更规范

- 回合引擎应保持：
  - 仅负责改变 `TurnState`（当前玩家、回合数、`CurrentPhase`）。
  - 具体牌/血量变化由 Resolver 和 CardMove 层通过显式调用完成。
- 优点：
  - 使回合推进逻辑保持纯粹，可单独测试。

---

## 7. 典型执行流程示例

### 7.1 从游戏开始到第一个玩家出牌

1. 上层创建 `Game`，调用对局初始化逻辑（见“对局初始化与开局流程” PLAN）。
2. 调用 `ITurnEngine.InitializeTurnState(game)`：
   - 选定首个玩家；
   - 设置 `TurnNumber = 1`, `CurrentPhase = Prepare`。
3. 上层调用 `AdvancePhase(game)`：
   - 状态从 `Prepare` → `Judge`。
4. 再调用 `AdvancePhase(game)`：
   - `Judge` → `Draw`，并在内部或外部调用 `DrawCards` 为当前玩家摸牌。
5. 再次 `AdvancePhase(game)`：
   - `Draw` → `Play`。
6. 在 `Play` 阶段内：
   - 上层循环：通过 `IActionQueryService` 获取可执行动作；
   - 根据玩家输入和动作执行结果，保持 `Phase = Play` 不变，直到玩家选择 `EndPhase` 动作；
   - 当动作被 Resolver/Actions 层确认结束该阶段后，引擎才允许 `AdvancePhase` 到 `Discard`。

### 7.2 回合结束与轮转到下一玩家

1. 玩家完成 `Discard` 阶段后调用 `AdvancePhase(game)`：
   - `Discard` → `End`。
2. 再 `AdvancePhase(game)`：
   - `End` 阶段完成；
   - 引擎内部调用 `StartNextTurn(game)`：
     - 选择下一个存活玩家；
     - `TurnNumber++`；
     - `CurrentPhase = Prepare`。

---

## 8. Turn/Phase 引擎与其它核心模块的关系图

```mermaid
flowchart TD
  modelLayer[ModelLayer(Game_Player_Card_Zone)]
  rulesLayer[RulesLayer]
  actionsLayer[ActionsLayer]
  turnEngine[TurnPhaseEngine]
  resolverLayer[ResolverLayer]
  responseSys[ResponseSystem]
  eventBus[EventBus_future]

  modelLayer --> rulesLayer
  modelLayer --> turnEngine
  rulesLayer --> actionsLayer
  actionsLayer --> turnEngine
  turnEngine --> resolverLayer
  resolverLayer --> responseSys
  turnEngine --> eventBus
```

---

## 9. 分阶段实现计划

### 阶段 1：状态类型与接口骨架

- **目标**：定义回合/阶段相关状态结构与接口，无具体逻辑。
- **工作项**：
  1. 在 `LegendOfThreeKingdoms.Core.Turns.Abstractions` 中定义：
     - `TurnState`, `PhaseState`（如需要）、`TurnTransitionResult`；
     - `ITurnEngine` 接口（`InitializeTurnState`, `StartNextTurn`, `AdvancePhase`, `GetCurrentTurnState`, `CanEndCurrentPhase` 等）。
  2. 在 `Game` 模型中接入 `TurnState` 字段。
  3. 编写最基础的构造/访问单元测试，保证类型和结构稳定。

### 阶段 2：最小顺序状态机实现

- **目标**：实现固定顺序的回合状态机，不接入技能/事件。
- **工作项**：
  1. 在 `LegendOfThreeKingdoms.Core.Turns.Basic` 中实现 `BasicTurnEngine`：
     - 硬编码阶段顺序：`Prepare → Judge → Draw → Play → Discard → End`；
     - `AdvancePhase` 按照这一顺序流转，并在 `End` 时调用 `StartNextTurn`。
  2. 在 `Draw` 阶段加入调用牌堆/摸牌逻辑（可通过简单服务或内联逻辑）。
  3. 为典型流程编写单元/轻量集成测试：
     - 初始化 → 连续多次 `AdvancePhase`，验证 `TurnNumber`、`CurrentPlayer` 与 `CurrentPhase` 序列正确。

### 阶段 3：与 Rules / Actions 对接与限制检查

- **目标**：让回合引擎与规则层、动作层协作，约束阶段结束条件。
- **工作项**：
  1. 在 `CanEndCurrentPhase` 或 `AdvancePhase` 内调用规则/动作层：
     - 检查当前阶段是否仍有必须完成的动作或强制要求（第一版可简单：出牌阶段随时允许结束）。
  2. 扩展 `TurnTransitionResult`：
     - 支持返回错误码（如 `PhaseCannotEndYet`），便于 UI/上层处理。
  3. 添加测试用例：
     - 在 Play 阶段通过某种策略验证（即便第一版允许随时结束，也要覆盖这个路径）。

---

## 10. 设计约束与最佳实践

- **单一职责**  
  - Turn/Phase 引擎只关心“谁的回合”、“当前在哪个阶段”、“下一步是什么阶段”，不关心牌的细节结算。
- **状态可追溯**  
  - `TurnState` 应易于序列化/记录，便于未来日志与回放系统直接使用。
- **与技能/事件松耦合**  
  - 在 Phase 切换点预留钩子（如未来触发事件），但当前实现不依赖任何 `EventBus`。
- **简化但不封死扩展**  
  - 第一版允许只实现最基础规则，但在接口和状态结构上预留合理余地（如 `SubPhase` 字段、扩展 `Phase` 枚举值）。

---

## 11. 完成定义（Definition of Done）

- **结构与接口**：
  - `LegendOfThreeKingdoms.Core.Turns.Abstractions` 中的 `ITurnEngine`、`TurnState` 等定义完整，通过编译。
  - `Game` 模型中集成回合/阶段状态字段。
- **基础实现**：
  - `BasicTurnEngine` 能够：
    - 初始化一局游戏的首个回合与阶段；
    - 在多玩家之间按座次轮转回合；
    - 以固定顺序推进阶段（准备 → 判定 → 摸牌 → 出牌 → 弃牌 → 结束）。
- **协作能力**：
  - 在 `Draw` 阶段可以调用简单摸牌逻辑；
  - 在 `Play` 阶段不阻塞 `ActionQueryService` 提供动作列表（即 Turn 引擎与 Rules/Actions 层配合良好）。
- **测试**：
  - 至少涵盖：
    - 单回合内完整阶段流转；
    - 多回合玩家轮转；
    - 卡组耗尽等边界情况下的安全行为（哪怕暂时简单返回错误码或结束对局标记）。
