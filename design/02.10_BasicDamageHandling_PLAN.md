# 基础 Damage 处理技术规划（PLAN）

> 聚焦于 `core_module_breakdown.md` 中的 **10. 基础 Damage 处理（不含濒死救援）**，在已有 **Resolution Pipeline（UseCard & Slash）** 之上，实现一个基础的伤害结算器，用于处理伤害的创建、应用和记录，为后续濒死流程、免伤、转移伤害等复杂机制预留扩展点。

---

## 1. 范围与目标

- **范围（Scope）**
  - 在 `core` Class Library 内，实现 `DamageResolver`：
    - 接收伤害参数（来源、目标、伤害值、伤害类型等）
    - 执行基础伤害结算：扣减目标体力
    - 记录伤害事件（通过日志系统）
    - 预留扩展字段用于后续功能（濒死判断、免伤、转移伤害等），但暂不实现这些复杂逻辑
  - 修改 `SlashResolver`，使其在杀命中后触发 `DamageResolver`
  - 约束：
    - **不实现濒死流程**（将在步骤 13 实现）
    - **不实现免伤逻辑**（将在响应链系统完成后实现）
    - **不实现伤害转移**（将在技能系统完成后实现）
    - **不引入事件总线**（将在步骤 14 实现），仅通过日志系统记录

- **目标（Goals）**
  - **统一伤害入口**：所有伤害结算都通过 `DamageResolver`，保证一致性
  - **可追踪**：每次伤害都记录到日志系统，包含来源、目标、伤害值、伤害类型等完整信息
  - **可扩展**：伤害描述结构预留字段，便于后续添加免伤、转移、属性伤害等机制
  - **可测试**：通过单元测试覆盖典型路径（正常伤害、伤害值边界、目标死亡边界等）

- **非目标（Non-Goals）**
  - 不在本模块内实现濒死判断和救援流程（步骤 13）
  - 不实现响应链系统（步骤 11-12），假设杀直接命中
  - 不实现完整的事件总线系统（步骤 14），仅使用现有日志接口
  - 不实现技能介入伤害修改（步骤 16）

---

## 2. 与现有模块的关系

### 2.1 上游依赖

- **Resolution Pipeline**（见 `core/Resolution.Basic.cs`）
  - `IResolver` 接口：`DamageResolver` 实现此接口
  - `ResolutionContext`：提供游戏状态、玩家信息、服务依赖
  - `IResolutionStack`：用于将 `DamageResolver` 推入结算栈
  - `SlashResolver`：在杀命中后需要触发 `DamageResolver`

- **模型层**（见 `core/Model/Player.cs`）
  - `Player.CurrentHealth`：需要扣减此字段
  - `Player.IsAlive`：伤害可能导致玩家死亡，需要更新此字段（但暂不触发濒死流程）

- **日志系统**（见 `core/Abstractions.ILogSink.cs`）
  - `ILogSink`：用于记录伤害事件
  - `LogEntry`：伤害事件将作为结构化日志条目记录

### 2.2 下游被依赖方

- **未来濒死流程**（步骤 13）
  - `DamageResolver` 完成后，将在伤害结算后检查体力是否 ≤ 0，触发 `DyingResolver`

- **未来响应链系统**（步骤 11-12）
  - 响应链完成后，`SlashResolver` 将在响应窗口结束后决定是否触发 `DamageResolver`

- **未来事件总线**（步骤 14）
  - 事件总线系统将订阅伤害事件，技能可以介入伤害计算

---

## 3. 命名空间与文件布局

- **命名空间**
  - 在现有 `LegendOfThreeKingdoms.Core.Resolution` 命名空间下添加伤害相关类型
  - 依赖 `LegendOfThreeKingdoms.Core.Model`、`LegendOfThreeKingdoms.Core.Abstractions`

- **文件结构建议**
  - `core/Resolution.Basic.cs`：
    - 添加 `DamageResolver` 类实现
    - 修改 `SlashResolver`，在杀命中后推入 `DamageResolver`
  - `core/Resolution.Abstractions.cs` 或新建 `core/Resolution.Damage.cs`：
    - `DamageType`：伤害类型枚举（普通伤害、火焰伤害、雷电伤害等）
    - `DamageDescriptor`：伤害描述结构，包含来源、目标、伤害值、伤害类型等字段，以及预留的扩展字段

> 如果伤害相关类型较多，可考虑新建 `Resolution.Damage.cs` 文件；否则直接添加到 `Resolution.Basic.cs` 和 `Resolution.Abstractions.cs`。

---

## 4. 核心抽象与数据结构

### 4.1 DamageType（伤害类型枚举）

定义在 `core/Resolution.Abstractions.cs` 或 `core/Resolution.Damage.cs`：

```csharp
public enum DamageType
{
    /// <summary>
    /// Normal damage (普通伤害)
    /// </summary>
    Normal = 0,
    
    /// <summary>
    /// Fire damage (火焰伤害)
    /// </summary>
    Fire,
    
    /// <summary>
    /// Thunder damage (雷电伤害)
    /// </summary>
    Thunder
}
```

- 初期仅实现 `Normal`，其他类型为后续扩展预留
- 伤害类型可能影响后续的免伤、属性伤害等机制

### 4.2 DamageDescriptor（伤害描述结构）

定义在 `core/Resolution.Abstractions.cs` 或 `core/Resolution.Damage.cs`：

```csharp
public sealed record DamageDescriptor(
    int SourceSeat,           // 伤害来源玩家座位号
    int TargetSeat,           // 伤害目标玩家座位号
    int Amount,               // 伤害值（必须 > 0）
    DamageType Type,          // 伤害类型
    string? Reason = null,    // 伤害原因（可选，如 "Slash"）
    
    // 预留扩展字段（暂不使用）
    bool IsPreventable = true,        // 是否可被免伤（预留）
    int? TransferredToSeat = null,    // 转移目标座位号（预留）
    bool TriggersDying = true         // 是否触发濒死（预留，当前始终为 true）
)
{
    public void Validate()
    {
        if (Amount <= 0)
            throw new ArgumentException("Damage amount must be positive", nameof(Amount));
        if (SourceSeat < 0)
            throw new ArgumentException("Source seat must be non-negative", nameof(SourceSeat));
        if (TargetSeat < 0)
            throw new ArgumentException("Target seat must be non-negative", nameof(TargetSeat));
    }
}
```

- `SourceSeat` 和 `TargetSeat`：使用座位号而非 Player 对象，避免循环引用
- `Amount`：必须为正数，由调用方保证
- `Reason`：可选字符串，用于日志记录（如 "Slash"、"Fire Attack" 等）
- 预留字段：`IsPreventable`、`TransferredToSeat`、`TriggersDying` 等，当前不参与逻辑，仅用于未来扩展

### 4.3 DamageResolver（伤害结算器）

实现 `IResolver` 接口，定义在 `core/Resolution.Basic.cs`：

**核心逻辑：**

1. 从 `ResolutionContext` 中提取 `DamageDescriptor`（可通过 `Choice` 或 `Action` 传递，或通过 context 扩展字段）
2. 验证伤害描述的有效性（目标存活、伤害值合法等）
3. 扣减目标玩家体力：`target.CurrentHealth = Math.Max(0, target.CurrentHealth - damage.Amount)`
4. 如果体力降至 0 或以下，更新 `target.IsAlive = false`（但**不触发濒死流程**）
5. 通过 `ILogSink` 记录伤害事件（如果 context 中提供了日志服务）
6. 返回成功结果

**如何传递 DamageDescriptor：**

- 方案 A：通过 `ResolutionContext` 扩展字段（推荐）
  - 在 `ResolutionContext` 中添加可选字段 `DamageDescriptor? PendingDamage`
  - `SlashResolver` 创建 `DamageDescriptor` 并设置到 context 中
  - `DamageResolver` 从 context 读取
- 方案 B：通过 `ChoiceResult` 的扩展字段
  - 在 `ChoiceResult` 中添加可选字段存储伤害信息
- 方案 C：通过 `ActionDescriptor` 的扩展字段

**推荐方案 A**，因为：

- `ResolutionContext` 是 resolver 之间的主要通信渠道
- 不污染 `ChoiceResult`（选择结果）和 `ActionDescriptor`（动作描述）的语义
- 便于后续扩展其他类型的 pending 状态

**日志记录：**

- 如果 `ResolutionContext` 中提供了 `ILogSink`（可通过依赖注入或扩展字段），记录 `LogEntry`：
  - `EventType = "DamageApplied"`
  - `Data` 包含：来源座位、目标座位、伤害值、伤害类型、原因、结算后体力等

---

## 5. 集成点修改

### 5.1 修改 ResolutionContext

在 `core/Resolution.Abstractions.cs` 中扩展 `ResolutionContext`：

```csharp
public sealed record ResolutionContext(
    Game Game,
    Player SourcePlayer,
    ActionDescriptor? Action,
    ChoiceResult? Choice,
    IResolutionStack Stack,
    ICardMoveService CardMoveService,
    IRuleService RuleService,
    
    // 新增可选字段
    DamageDescriptor? PendingDamage = null,  // 待结算的伤害
    ILogSink? LogSink = null                 // 日志服务（可选）
);
```

### 5.2 修改 SlashResolver

在 `core/Resolution.Basic.cs` 中修改 `SlashResolver.Resolve` 方法：

在杀命中后（当前 TODO 注释处），创建 `DamageDescriptor` 并推入 `DamageResolver`：

```csharp
// 在 SlashResolver.Resolve 方法中，验证目标后：
// 创建伤害描述
var damage = new DamageDescriptor(
    SourceSeat: sourcePlayer.Seat,
    TargetSeat: target.Seat,
    Amount: 1,  // 基础杀的伤害值为 1
    Type: DamageType.Normal,
    Reason: "Slash"
);

// 创建新的 context，包含待结算的伤害
var damageContext = new ResolutionContext(
    context.Game,
    context.SourcePlayer,
    context.Action,
    context.Choice,
    context.Stack,
    context.CardMoveService,
    context.RuleService,
    PendingDamage: damage,
    LogSink: context.LogSink
);

// 推入 DamageResolver
context.Stack.Push(new DamageResolver(), damageContext);

return ResolutionResult.SuccessResult;
```

---

## 6. 实现步骤

### 步骤 1：定义伤害类型和描述结构

- 在 `core/Resolution.Abstractions.cs` 或新建 `core/Resolution.Damage.cs` 中：
  - 定义 `DamageType` 枚举
  - 定义 `DamageDescriptor` record，包含核心字段和预留扩展字段
  - 实现 `DamageDescriptor.Validate()` 方法

### 步骤 2：扩展 ResolutionContext

- 在 `core/Resolution.Abstractions.cs` 中：
  - 为 `ResolutionContext` 添加 `PendingDamage` 和 `LogSink` 可选字段
  - 更新所有创建 `ResolutionContext` 的地方（可能需要更新多个文件）

### 步骤 3：实现 DamageResolver

- 在 `core/Resolution.Basic.cs` 中：
  - 实现 `DamageResolver` 类，实现 `IResolver` 接口
  - 从 context 读取 `PendingDamage`
  - 验证伤害描述和目标状态
  - 扣减目标体力
  - 更新目标存活状态（如果体力 ≤ 0）
  - 记录日志（如果提供了 `LogSink`）
  - 返回成功结果

### 步骤 4：修改 SlashResolver

- 在 `core/Resolution.Basic.cs` 中：
  - 修改 `SlashResolver.Resolve` 方法
  - 在杀命中后创建 `DamageDescriptor`
  - 创建包含 `PendingDamage` 的新 context
  - 推入 `DamageResolver` 到结算栈

### 步骤 5：更新 ResolutionExtensions

- 在 `core/Resolution.Extensions.cs` 中：
  - 如果 `RegisterUseSlashHandler` 需要传递 `ILogSink`，更新方法签名和调用

### 步骤 6：编写单元测试

- 在 `core.Tests/ResolutionTests.cs` 或新建 `core.Tests/DamageResolverTests.cs` 中：
  - 测试正常伤害结算（扣减体力）
  - 测试伤害导致体力为 0 的情况（更新 `IsAlive`）
  - 测试伤害导致体力为负数的情况（应限制为 0）
  - 测试无效伤害描述（负数伤害、无效目标等）
  - 测试日志记录（如果提供了 `LogSink`）

---

## 7. 测试策略

### 7.1 单元测试覆盖

**DamageResolver 测试：**

- 正常伤害：来源对目标造成 1 点伤害，验证体力正确扣减
- 多次伤害：连续造成伤害，验证体力累计扣减
- 伤害导致死亡：伤害后体力 ≤ 0，验证 `IsAlive` 被设置为 `false`
- 伤害值边界：伤害值等于当前体力、大于当前体力
- 无效输入：负数伤害值、无效座位号、目标已死亡等

**集成测试（SlashResolver + DamageResolver）：**

- 出杀命中后，验证目标体力被扣减
- 出杀导致目标死亡，验证 `IsAlive` 状态更新

**日志测试：**

- 如果提供了 `LogSink`，验证伤害事件被正确记录
- 验证日志条目包含所有必要信息

### 7.2 测试数据准备

- 创建最小游戏状态：2 个玩家，初始体力为 4
- 模拟出杀场景：玩家 A 对玩家 B 出杀
- 验证伤害结算后的游戏状态

---

## 8. 后续扩展点

本实现为以下功能预留了扩展点：

1. **濒死流程**（步骤 13）：

   - `DamageResolver` 结算后，检查 `target.CurrentHealth <= 0 && damage.TriggersDying`
   - 如果满足条件，推入 `DyingResolver` 到结算栈

2. **免伤机制**（步骤 12 响应链完成后）：

   - 在 `DamageResolver` 执行前，检查 `damage.IsPreventable`
   - 如果可免伤，开启响应窗口（如【闪】）
   - 如果免伤成功，跳过 `DamageResolver`

3. **伤害转移**（步骤 16 技能系统完成后）：

   - 技能可以修改 `damage.TransferredToSeat`
   - `DamageResolver` 检查此字段，如果非空，将伤害转移到新目标

4. **伤害修改**（步骤 16 技能系统完成后）：

   - 技能可以修改 `damage.Amount`（如伤害 +1）
   - 技能可以修改 `damage.Type`（如改为火焰伤害）

5. **事件总线集成**（步骤 14）：

   - 将日志记录替换为事件总线发布
   - 发布 `DamageCreated`、`DamageApplied`、`AfterDamage` 等事件

---

## 9. 注意事项

1. **体力边界处理**：

   - 伤害后体力不能为负数，应限制为 `Math.Max(0, currentHealth - amount)`
   - 体力为 0 时，`IsAlive` 应设置为 `false`

2. **目标验证**：

   - `DamageResolver` 应验证目标玩家存在且存活
   - 如果目标已死亡，应返回失败或跳过伤害（根据游戏规则决定）

3. **日志服务可选性**：

   - `ILogSink` 是可选的，`DamageResolver` 应优雅处理其缺失的情况
   - 如果未提供日志服务，伤害仍应正常结算

4. **扩展字段暂不使用**：

   - 预留字段（`IsPreventable`、`TransferredToSeat` 等）在当前实现中不参与逻辑
   - 这些字段仅用于未来扩展，不应影响当前的基础伤害结算

5. **与 SlashResolver 的集成**：

   - `SlashResolver` 当前假设杀直接命中（无响应链）
   - 后续响应链系统完成后，`SlashResolver` 需要修改，在响应窗口结束后决定是否触发伤害
