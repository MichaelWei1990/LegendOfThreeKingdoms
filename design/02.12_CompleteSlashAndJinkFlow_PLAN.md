# 完善 Slash + Jink（杀 / 闪）的流程技术规划（PLAN）

> 聚焦于 `core_module_breakdown.md` 中的 **12. 完善 Slash + Jink（杀 / 闪）的流程**，在已有 **Resolution Pipeline（UseCard & Slash）**、**Response System 骨架** 和 **DamageResolver** 基础上，将 `SlashResolver` 与响应系统打通，实现完整的"出杀 → 响应窗口 → 伤害结算或免伤"流程。

---

## 1. 范围与目标

- **范围（Scope）**
  - 修改 `SlashResolver`，在杀命中前推入响应窗口，允许目标玩家打出【闪】
  - 根据响应窗口的结果决定是否触发 `DamageResolver`：
    - 无人响应（`NoResponse`）→ 触发伤害结算
    - 成功响应（`ResponseSuccess`）→ 不触发伤害结算，杀被闪避
  - 扩展 `ResolutionContext` 以支持传递 `getPlayerChoice` 函数
  - 修改 `RegisterUseSlashHandler` 以接收并传递 `getPlayerChoice` 函数
  - 约束：
    - **不实现复杂响应链**（如追击、替换响应等），先仅支持基础响应流程
    - **不引入事件总线**（将在步骤 14 实现），但为未来事件发布预留接口
    - **不实现濒死流程**（将在步骤 13 实现），伤害结算后暂不触发濒死判断

- **目标（Goals）**
  - **完整流程**：实现从"出杀"到"伤害结算或免伤"的完整闭环
  - **响应集成**：将响应窗口无缝集成到 Resolution Pipeline 中
  - **状态驱动**：根据响应窗口结果正确决定后续流程
  - **可测试**：通过单元测试覆盖所有分支（无人响应、成功响应、响应失败等）

- **非目标（Non-Goals）**
  - 不实现复杂响应链机制（如追击、替换响应等）
  - 不实现完整事件总线（步骤 14）
  - 不实现濒死与救援流程（步骤 13）
  - 不实现技能介入响应流程（步骤 16）

---

## 2. 与现有模块的关系

### 2.1 上游依赖

- **Resolution Pipeline**（见 `core/Resolution.Basic.cs`）
  - `SlashResolver`：需要修改，在杀命中前推入响应窗口
  - `ResolutionContext`：需要扩展，添加 `getPlayerChoice` 函数字段
  - `IResolutionStack`：用于推入响应窗口 resolver

- **Response System**（见 `core/Response.Basic.cs` 和 `core/Response.Extensions.cs`）
  - `ResponseWindowResolver`：响应窗口的 resolver 实现
  - `BasicResponseWindow`：响应窗口的执行逻辑
  - `ResponseExtensions.CreateJinkResponseWindow`：创建【闪】响应窗口的扩展方法
  - `ResponseWindowResult`：响应窗口的执行结果

- **规则服务层**（见 `core/Rules.Basic.cs`）
  - `IResponseRuleService`：判断玩家是否有资格响应、哪些牌可以作为响应
  - `ResponseType.JinkAgainstSlash`：响应类型枚举

- **动作与选择层**（见 `core/Actions.Mapping.cs`）
  - `ActionResolutionMapper`：需要修改 `RegisterUseSlashHandler` 以接收 `getPlayerChoice` 函数

### 2.2 下游被依赖方

- **濒死流程**（步骤 13）
  - 伤害结算完成后，将检查体力是否 ≤ 0，触发 `DyingResolver`

- **事件总线与技能引擎**（步骤 14-16）
  - 响应窗口和伤害结算在关键节点发布事件，供技能系统订阅和介入

- **日志与回放系统**（步骤 17-18）
  - 响应窗口和伤害结算的状态变化将用于生成结构化日志和回放记录

---

## 3. 核心修改点

### 3.1 扩展 ResolutionContext

在 `core/Resolution.Abstractions.cs` 中扩展 `ResolutionContext`，添加 `getPlayerChoice` 函数字段和 `IntermediateResults` 字典：

```csharp
public sealed record ResolutionContext(
    Game Game,
    Player SourcePlayer,
    ActionDescriptor? Action,
    ChoiceResult? Choice,
    IResolutionStack Stack,
    ICardMoveService CardMoveService,
    IRuleService RuleService,
    DamageDescriptor? PendingDamage = null,
    ILogSink? LogSink = null,
    Func<ChoiceRequest, ChoiceResult>? GetPlayerChoice = null,
    Dictionary<string, object>? IntermediateResults = null
);
```

**设计原则**：
- `GetPlayerChoice` 为可选字段，因为不是所有 resolver 都需要响应窗口
- `IntermediateResults` 为可选字典，用于在 resolver 之间传递中间结果（如响应窗口结果）
- 当需要创建响应窗口时，`SlashResolver` 从 context 中读取此函数
- 如果未提供 `GetPlayerChoice`，响应窗口将无法执行（应返回错误）

### 3.2 修改 RegisterUseSlashHandler

在 `core/Resolution.Extensions.cs` 中修改 `RegisterUseSlashHandler`，接收 `getPlayerChoice` 函数并传递到 `ResolutionContext`：

```csharp
public static void RegisterUseSlashHandler(
    this ActionResolutionMapper mapper,
    ICardMoveService cardMoveService,
    IRuleService ruleService,
    Func<ChoiceRequest, ChoiceResult>? getPlayerChoice = null)
{
    // ... 现有代码 ...
    
    var resolutionContext = new ResolutionContext(
        context.Game,
        context.CurrentPlayer,
        action,
        playerChoice,
        stack,
        cardMoveService,
        ruleService,
        GetPlayerChoice: getPlayerChoice
    );
    
    // ... 现有代码 ...
}
```

**设计原则**：
- `getPlayerChoice` 函数由上层引擎提供，负责等待玩家选择并返回 `ChoiceResult`
- 函数可能阻塞，直到玩家做出选择
- 如果上层引擎不支持响应窗口，可以传递 `null`，但 `SlashResolver` 将无法创建响应窗口

### 3.3 修改 ResponseWindowResolver

在 `core/Response.Basic.cs` 中修改 `ResponseWindowResolver.Resolve` 方法，将响应结果存储到 `IntermediateResults` 字典中：

```csharp
public ResolutionResult Resolve(ResolutionContext context)
{
    // ... 执行响应窗口 ...
    
    // Store response result in IntermediateResults dictionary for subsequent resolvers
    if (context.IntermediateResults is null)
    {
        throw new InvalidOperationException(
            "IntermediateResults dictionary is required for ResponseWindowResolver. " +
            "It should be created by SlashResolver before pushing the response window.");
    }

    context.IntermediateResults["LastResponseResult"] = result;
    
    // ... 返回结果 ...
}
```

**设计原则**：
- 响应结果存储在共享的 `IntermediateResults` 字典中
- 字典应该由 `SlashResolver` 创建并传递给所有相关 resolver
- 后续的 `SlashResponseHandlerResolver` 可以从字典中读取响应结果

### 3.4 创建 SlashResponseHandlerResolver

在 `core/Resolution.Basic.cs` 中创建新的 resolver：

```csharp
public sealed class SlashResponseHandlerResolver : IResolver
{
    private readonly DamageDescriptor _pendingDamage;

    public SlashResponseHandlerResolver(DamageDescriptor pendingDamage)
    {
        _pendingDamage = pendingDamage ?? throw new ArgumentNullException(nameof(pendingDamage));
    }

    public ResolutionResult Resolve(ResolutionContext context)
    {
        // Read response window result from IntermediateResults dictionary
        var intermediateResults = context.IntermediateResults;
        if (intermediateResults is null || !intermediateResults.TryGetValue("LastResponseResult", out var resultObj))
        {
            return ResolutionResult.Failure(
                ResolutionErrorCode.InvalidState,
                messageKey: "resolution.slash.noResponseResult");
        }

        if (resultObj is not ResponseWindowResult responseResult)
        {
            return ResolutionResult.Failure(
                ResolutionErrorCode.InvalidState,
                messageKey: "resolution.slash.invalidResponseResult");
        }

        // Decide whether to trigger damage based on response result
        if (responseResult.State == ResponseWindowState.NoResponse)
        {
            // No response - trigger damage
            var damageContext = new ResolutionContext(
                context.Game,
                context.SourcePlayer,
                context.Action,
                context.Choice,
                context.Stack,
                context.CardMoveService,
                context.RuleService,
                PendingDamage: _pendingDamage,
                LogSink: context.LogSink,
                context.GetPlayerChoice,
                context.IntermediateResults
            );

            context.Stack.Push(new DamageResolver(), damageContext);
        }
        else if (responseResult.State == ResponseWindowState.ResponseSuccess)
        {
            // Response successful - slash dodged, no damage
            // Just return success
        }

        return ResolutionResult.SuccessResult;
    }
}
```

**执行顺序**：
1. `SlashResolver` 推入 `SlashResponseHandlerResolver`（先推入，后执行）
2. `SlashResolver` 推入 `ResponseWindowResolver`（后推入，先执行）
3. 结算栈执行：先执行 `ResponseWindowResolver`，再执行 `SlashResponseHandlerResolver`
4. `SlashResponseHandlerResolver` 根据响应结果决定是否触发伤害

### 3.5 修改 SlashResolver

在 `core/Resolution.Basic.cs` 中修改 `SlashResolver.Resolve` 方法：

**核心流程**：
1. 提取目标玩家（现有逻辑）
2. 验证目标存活（现有逻辑）
3. **新增**：检查 `context.GetPlayerChoice` 是否提供
   - 如果未提供，返回错误（响应窗口需要此函数）
4. **新增**：创建响应窗口并推入结算栈
   - 使用 `ResponseExtensions.CreateJinkResponseWindow` 创建响应窗口
   - 推入 `ResponseWindowResolver` 到结算栈
5. **新增**：创建 `SlashResponseHandlerResolver` 并推入结算栈
   - 创建 `DamageDescriptor`（待用）
   - 推入 `SlashResponseHandlerResolver` 到结算栈

**关键实现细节**：
- 创建并共享 `IntermediateResults` 字典，确保所有 resolver 使用同一个字典实例
- 利用 LIFO 栈的特性，先推入 `SlashResponseHandlerResolver`，后推入 `ResponseWindowResolver`，确保响应窗口先执行

---

## 4. 算法与流程示例

### 4.1 典型流程：出杀 → 响应窗口 → 伤害或免伤

1. **玩家选择动作**：
   - UI/调用方调用 `IRuleService.GetAvailableActions()`，获得 `ActionDescriptor(ActionId: "UseSlash", ...)`
   - 玩家选择目标和牌，生成 `ChoiceResult`

2. **进入 Resolution Pipeline**：
   - `IActionResolutionMapper.Resolve()` 被调用，查找 `"UseSlash"` 的 handler
   - Handler 创建 `ResolutionContext`（包含 `Game`、`SourcePlayer`、`Action`、`Choice`、`Stack`、服务依赖、`GetPlayerChoice`）
   - Handler 创建 `UseCardResolver` 并推入结算栈

3. **UseCardResolver 执行**：
   - 从 `ChoiceResult` 提取牌和目标
   - 调用规则服务进行最终校验
   - 调用牌移动服务将【杀】从手牌移动到弃牌堆
   - 创建 `SlashResolver` 并推入结算栈

4. **SlashResolver 执行**：
   - 从上下文提取目标玩家
   - 验证目标存活
   - 验证 `GetPlayerChoice` 是否提供
   - 创建 `DamageDescriptor`（待用）
   - 创建并共享 `IntermediateResults` 字典
   - 创建响应窗口并推入结算栈：`stack.Push(responseWindow, context)`
   - 创建 `SlashResponseHandlerResolver` 并推入结算栈：`stack.Push(handlerResolver, context)`

5. **ResponseWindowResolver 执行**（由结算栈驱动）：
   - 创建 `BasicResponseWindow` 并执行
   - 按顺序询问目标玩家是否打出【闪】
   - 如果玩家选择响应：
     - 验证选择的牌是否合法
     - 将响应牌从手牌移动到弃牌堆
     - 将响应结果存储到 `IntermediateResults` 字典中
     - 返回 `ResolutionResult.Success`
   - 如果玩家选择不响应：
     - 将响应结果（`NoResponse`）存储到 `IntermediateResults` 字典中
     - 返回 `ResolutionResult.Success`

6. **SlashResponseHandlerResolver 执行**（由结算栈驱动）：
   - 从 `IntermediateResults` 字典中读取响应窗口结果
   - 如果 `State == NoResponse`：
     - 创建包含 `PendingDamage` 的新 context
     - 推入 `DamageResolver` 到结算栈
   - 如果 `State == ResponseSuccess`：
     - 不触发伤害结算，返回成功（杀被闪避）

7. **DamageResolver 执行**（如果需要）：
   - 从 context 读取 `PendingDamage`
   - 扣减目标体力
   - 更新目标存活状态（如果体力 ≤ 0）
   - 记录日志

8. **结算完成**：
   - 结算栈为空，返回最终结果给调用方

### 4.2 错误处理策略

- **GetPlayerChoice 未提供**：
  - `SlashResolver` 返回错误，不创建响应窗口

- **响应窗口执行失败**：
  - `ResponseWindowResolver` 返回错误，`SlashResponseHandlerResolver` 检查错误并决定是否触发伤害（默认触发伤害）

- **响应牌移动失败**：
  - `BasicResponseWindow` 记录错误，继续询问下一个玩家或返回 `NoResponse`

---

## 5. 实现步骤

### 步骤 1：扩展 ResolutionContext

- 在 `core/Resolution.Abstractions.cs` 中：
  - 为 `ResolutionContext` 添加 `GetPlayerChoice` 可选字段
  - 为 `ResolutionContext` 添加 `IntermediateResults` 可选字典字段
  - 更新所有创建 `ResolutionContext` 的地方（可能需要更新多个文件）

### 步骤 2：修改 RegisterUseSlashHandler

- 在 `core/Resolution.Extensions.cs` 中：
  - 修改 `RegisterUseSlashHandler` 方法签名，添加 `getPlayerChoice` 参数
  - 在创建 `ResolutionContext` 时传递 `getPlayerChoice`
  - 更新调用 `RegisterUseSlashHandler` 的地方（需要上层引擎提供 `getPlayerChoice` 函数）

### 步骤 3：修改 ResponseWindowResolver

- 在 `core/Response.Basic.cs` 中：
  - 修改 `ResponseWindowResolver.Resolve` 方法
  - 执行响应窗口后，将响应结果存储到 `IntermediateResults` 字典中
  - 验证字典已存在（由 `SlashResolver` 创建），否则抛出异常

### 步骤 4：创建 SlashResponseHandlerResolver

- 在 `core/Resolution.Basic.cs` 中：
  - 创建 `SlashResponseHandlerResolver` 类
  - 实现 `IResolver` 接口
  - 从 `IntermediateResults` 字典中读取响应窗口结果
  - 根据结果决定是否触发伤害结算

### 步骤 5：修改 SlashResolver

- 在 `core/Resolution.Basic.cs` 中：
  - 修改 `SlashResolver.Resolve` 方法
  - 验证 `GetPlayerChoice` 是否提供
  - 创建并共享 `IntermediateResults` 字典
  - 创建响应窗口并推入结算栈
  - 创建 `DamageDescriptor` 并推入 `SlashResponseHandlerResolver`
  - 确保执行顺序：响应窗口 → 响应处理 → 伤害结算（如果需要）

### 步骤 6：更新测试

- 在 `core.Tests/ResolutionTests.cs` 中：
  - 更新现有测试以提供 `getPlayerChoice` 函数
  - 添加新测试覆盖响应窗口流程：
    - 测试 `GetPlayerChoice` 未提供的情况
    - 测试无人响应的情况（触发伤害）
    - 测试成功响应的情况（不触发伤害）
    - 测试响应窗口执行顺序

---

## 6. 测试策略

### 6.1 单元测试覆盖

**SlashResolver 测试**：
- 验证 `GetPlayerChoice` 未提供时返回错误
- 验证响应窗口被正确创建和推入
- 验证 `SlashResponseHandlerResolver` 被正确推入

**SlashResponseHandlerResolver 测试**：
- 测试无人响应的情况（触发伤害）
- 测试成功响应的情况（不触发伤害）
- 测试响应结果未找到的情况（错误处理）

**集成测试**：
- 完整流程：出杀 → 响应窗口（无人响应）→ 伤害结算
- 完整流程：出杀 → 响应窗口（成功响应）→ 不触发伤害
- 验证响应牌正确移动到弃牌堆
- 验证伤害正确扣减体力

### 6.2 测试数据准备

- 创建最小游戏状态：2 个玩家，初始体力为 4
- 模拟响应场景：
  - 玩家 A 对玩家 B 出杀
  - 玩家 B 有【闪】可以选择响应
  - 玩家 B 无【闪】无法响应
- 验证响应窗口执行后的游戏状态和伤害结算结果

---

## 7. 后续扩展点

本实现为以下功能预留了扩展点：

1. **复杂响应链**（步骤 12 之后）：
   - 支持追击机制（如【青龙偃月刀】在杀被闪后触发追加出杀窗口）
   - 支持替换响应、取消响应等复杂机制

2. **事件总线集成**（步骤 14）：
   - 响应窗口和伤害结算在关键节点发布事件（如 `SlashUsed`、`JinkPlayed`、`DamageApplied`）
   - 技能可以订阅这些事件并介入响应流程

3. **技能介入**（步骤 16）：
   - 技能可以修改响应顺序、响应资格、可用响应牌等
   - 技能可以修改伤害值、伤害类型等

---

## 8. 注意事项

1. **GetPlayerChoice 函数提供**：
   - `getPlayerChoice` 函数必须由上层引擎提供
   - 函数可能阻塞，直到玩家做出选择
   - 如果上层引擎不支持响应窗口，可以传递 `null`，但 `SlashResolver` 将返回错误

2. **响应结果传递**：
   - 由于 `ResolutionContext` 是不可变的 record，需要使用 `IntermediateResults` 字典传递响应结果
   - 确保响应结果在 `SlashResponseHandlerResolver` 执行时可用
   - 字典应该由 `SlashResolver` 创建并共享给所有相关 resolver

3. **执行顺序**：
   - 确保响应窗口在 `SlashResponseHandlerResolver` 之前执行
   - 确保 `SlashResponseHandlerResolver` 在 `DamageResolver`（如果需要）之前执行
   - 利用 LIFO 栈的特性，先推入的 resolver 后执行

4. **状态修改的原子性**：
   - 响应窗口执行过程中可能修改游戏状态（如打出响应牌）
   - 如果响应窗口执行失败，需要考虑状态回滚（当前实现暂不考虑，后续可能需要）

5. **与现有代码的兼容性**：
   - 修改 `RegisterUseSlashHandler` 的签名可能影响现有调用代码
   - 需要更新所有调用 `RegisterUseSlashHandler` 的地方

---

## 9. 完成定义（Definition of Done）

- **结构与接口**：
  - `ResolutionContext` 已扩展，包含 `GetPlayerChoice` 和 `IntermediateResults` 字段
  - `RegisterUseSlashHandler` 已修改，接收并传递 `getPlayerChoice` 函数
  - `SlashResponseHandlerResolver` 已创建并实现

- **功能实现**：
  - `SlashResolver` 能够：
    - 验证 `GetPlayerChoice` 是否提供
    - 创建响应窗口并推入结算栈
    - 创建 `SlashResponseHandlerResolver` 并推入结算栈
  - `SlashResponseHandlerResolver` 能够：
    - 从 context 读取响应窗口结果
    - 根据结果决定是否触发伤害结算
  - `ResponseWindowResolver` 能够：
    - 将响应结果存储到 context 的 `IntermediateResults` 字典中

- **集成与测试**：
  - 完整流程测试覆盖：
    - 出杀 → 响应窗口（无人响应）→ 伤害结算
    - 出杀 → 响应窗口（成功响应）→ 不触发伤害
  - 新增针对响应流程的单元测试覆盖至少：
    - `GetPlayerChoice` 未提供的情况
    - 无人响应的情况
    - 成功响应的情况
    - 响应结果传递的正确性
  - 现有测试（如 `ResolutionTests`）全部通过
  - 确认在固定 seed 和相同选择序列下，响应流程执行结果完全确定

- **文档**：
  - 本 `PLAN.md` 已与其它 `*_PLAN.md` 文档在命名与职责划分上保持一致，并在必要位置添加交叉引用











