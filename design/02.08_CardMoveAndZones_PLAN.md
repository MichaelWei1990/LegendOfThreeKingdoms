# 三国杀 Core 牌移动与区域服务技术规划（PLAN）

> 聚焦于 `core_module_breakdown.md` 中的 **8. 牌移动与区域服务**，在已有 **模型层（Game/Player/Card/Zone）**、**基础规则服务** 与 **回合/阶段引擎** 之上，引入一个统一的、可扩展的牌移动服务，用于在各个 `Zone` 之间安全地移动牌，并为后续技能、日志与事件系统提供稳定扩展点。

---

## 1. 范围与目标

- **范围（Scope）**  
  - 在 `core` Class Library 内，为 `LegendOfThreeKingdoms.Core.Model.Zones.IZone` / `Zone` 提供一层**行为性服务**：
    - 支持从一个区域（`IZone`）移动一张或多张牌到另一个区域（例如 `DrawPile` → 玩家 `HandZone`、`HandZone` → `DiscardPile`）。
    - 提供若干基础高层操作的语义封装：抽牌、弃牌、从手牌打出牌后进入弃牌堆等。
    - 在每次移动前后生成结构化的 `BeforeMove` / `AfterMove` 事件对象，为未来事件总线与技能引擎预留挂载点。
  - 约束：
    - **不引入 UI / 网络 依赖**，只操作 `Game` 内存状态与纯 DTO。
    - **不实现复杂结算逻辑**（如杀命中、伤害、濒死），仅负责**“牌在各区域之间的物理流转”**。

- **目标（Goals）**  
  - **单一入口**：后续所有牌移动（抽牌、弃牌、判定牌进出等）均通过统一服务，避免各处直接操作 `Zone.MutableCards`。  
  - **可追踪**：每次移动都生成标准化的 `CardMoveRecord`（含来源、去向、原因、顺序信息），可用于日志和回放。  
  - **可组合**：既能被 `GameSetup.Basic` 等初始化逻辑调用，也能被未来的 `UseCard` / `Slash` / `Damage` resolver 复用。  
  - **可测试**：通过单元测试覆盖典型路径（抽牌、弃牌、多张批量移动、非法移动防御）。

- **非目标（Non-Goals）**  
  - 不在本模块内实现完整的响应链、伤害或技能逻辑，只保证这些流程在需要移动牌时有统一的 API 可用。  
  - 不设计完整的全局事件总线，只提供面向未来 `IEventBus` 的事件结构和挂接点。  
  - 不关心牌的表现层（正面/背面、动画顺序），仅在必要时以布尔/标志位表达“是否公开”等信息。

---

## 2. 与现有模块的关系

### 2.1 上游依赖

- **模型层**（见 `02.02_ModelLayerGamePlayerCardZone_PLAN.md`）  
  - `LegendOfThreeKingdoms.Core.Model.Game`：
    - 暴露 `DrawPile : IZone`、`DiscardPile : IZone` 与 `IReadOnlyList<Player> Players`。  
  - `LegendOfThreeKingdoms.Core.Model.Player`：
    - 暴露 `HandZone : IZone`、`EquipmentZone : IZone`、`JudgementZone : IZone`。  
  - `LegendOfThreeKingdoms.Core.Model.Zones.IZone` / `Zone` / `ZoneIds`：
    - 只提供 **只读** 视图与内部 `MutableCards` 列表，当前已有部分代码直接操作 `MutableCards`（例如 `GameSetup.Basic.cs`）。

- **基础规则与回合引擎**（见 `02.04_BasicRuleServicesAndQueries_PLAN.md`, `02.06_TurnAndPhaseEngine_PLAN.md`）  
  - 规则服务只读取牌的存在与类型，并不改变牌位置。牌位置变化由本模块负责。  
  - `BasicTurnEngine` 与本模块无直接依赖，只通过 `Game` 状态（当前玩家/阶段）间接影响“谁可以移动哪些牌”。

### 2.2 下游被依赖方

- **对局初始化与开局流程**（当前实现于 `GameSetup.Basic.cs`，见 `02.07_GameInitializationAndOpening_PLAN.md`）  
  - 目前：`DealInitialHands` 直接从 `DrawPile` 读写 `Zone.MutableCards` 分发手牌。  
  - 目标：迁移为通过牌移动服务执行“抽初始手牌”。

- **未来解析与结算管线**（`UseCardResolver` / `SlashResolver` / `DamageResolver` 等）  
  - 需要：
    - `HandZone` → `DiscardPile` 的打出/弃置。  
    - `DrawPile` → `JudgementZone` 的判定牌翻出与回收。  
    - `DrawPile` → `HandZone` 的摸牌。  
  - 都应依赖本模块的统一牌移动 API。

- **未来事件总线与技能引擎**  
  - `CardMoved` 将是关键事件类型之一：技能可能在 Before/After Move 节点改写/响应移动。  
  - 本模块负责定义 `CardMoveEvent` / `CardMoveReason` 等结构，为事件总线提供标准 payload。

---

## 3. 命名空间与文件布局建议

- **命名空间**  
  - 引入新的功能命名空间：`LegendOfThreeKingdoms.Core.Zones`：
    - 专注于“牌在各个 Zone 之间如何流动”的服务与 DTO。  
    - 依赖 `LegendOfThreeKingdoms.Core.Model` 与 `LegendOfThreeKingdoms.Core.Model.Zones`，不反向依赖 `Rules` / `Turns` / `Actions`。

- **文件结构建议**  
  - `core/Zones.Abstractions.cs`：
    - `ICardMoveService`：统一牌移动服务接口。  
    - `CardMoveReason`：枚举移动原因（抽牌、弃牌、打出、判定、返回牌堆等）。  
    - `CardMoveOrdering`：描述插入位置（牌堆顶/牌堆底/保持顺序等）。  
    - `CardMoveDescriptor` / `CardMoveResult`：单次或批量移动的结构化描述与结果。  
    - `CardVisibility` 或简单布尔：是否在移动过程中向所有玩家公开。
  - `core/Zones.Basic.cs`：
    - `BasicCardMoveService`：基于当前 `Game` / `Zone` 的最小实现。  
    - 内部辅助方法（不对外暴露）：
      - 查找 Zone、检查牌是否存在、统一执行“从源移除/加入目标”的算法。  
  - 后续可选：`core/Zones.Events.cs`（若事件相关 DTO 较多时拆分）。

> 命名风格与 `GameSetup.Abstractions.cs` / `GameSetup.Basic.cs`, `Turns.Abstractions.cs` / `Turns.Basic.cs` 保持一致，便于后续查找和维护。

---

## 4. 核心抽象与数据结构

- **CardMoveReason（移动原因枚举）**  
  - 典型值：
    - `Draw`：摸牌（`DrawPile` → `HandZone`）。  
    - `Discard`：弃牌（通常 `HandZone` / `JudgementZone` / `EquipmentZone` → `DiscardPile`）。  
    - `Play`：打出牌后进入弃牌堆（出杀、出桃等）。  
    - `JudgementAttach` / `JudgementResolve`：判定牌进出判定区。  
    - `ReturnToDeckTop` / `ReturnToDeckBottom`：部分牌效果要求回到牌堆顶/底。  
  - 要求：语义**仅描述“为什么移动”**，具体规则效果由上层 resolver/技能解释。

- **CardMoveOrdering（插入顺序）**  
  - 用于描述牌在目标区域内的位置：
    - `ToTop`：例如摸牌；  
    - `ToBottom`：例如部分锦囊将牌置于牌堆底；  
    - `PreserveRelativeOrder`：批量移动时保持原有顺序（如多张牌一起弃置）。

- **CardMoveDescriptor / CardMoveRequest**  
  - 字段示意（不写具体签名）：
    - 源区标识：`SourceZoneId` + 可选 `SourceOwnerSeat`。  
    - 目标区标识：`TargetZoneId` + 可选 `TargetOwnerSeat`。  
    - 参与移动的牌：可通过 **牌实例引用** 或 **牌 Id 列表** 表示；首版可直接用 `Card` 实例集合。  
    - 移动原因：`CardMoveReason`。  
    - 顺序策略：`CardMoveOrdering`。  
    - 可选：是否在移动过程中翻开/公开（与 `IZone.IsPublic` 联合解释）。

- **CardMoveRecord / CardMoveResult**  
  - 在一次移动完成后生成的只读记录：
    - 包含原位置与新位置（区域 Id + 索引）、参与移动的牌 Id 列表。  
    - 用作：
      - `BeforeMove` / `AfterMove` 事件 payload；  
      - 未来日志事件 `CardMoved` 的基础数据结构。

---

## 5. 牌移动服务接口设计

- **ICardMoveService 核心职责**  
  - 核心方法群（只描述语义）：
    - `MoveSingle(game, card, fromZone, toZone, reason, ordering)`：
      - 验证 `card` 当前确实位于 `fromZone`；  
      - 从 `fromZone` 移除后，按 `ordering` 插入 `toZone`；  
      - 生成 `BeforeMove` / `AfterMove` 事件记录。  
    - `MoveMany(game, cards, fromZone, toZone, reason, ordering)`：
      - 一次性移动多张牌，保持批次操作的原子性（要么全部成功，要么失败不改变状态）。  
    - 高层语义封装：
      - `DrawCards(game, player, count)`：等价于从 `game.DrawPile` 依次移动到 `player.HandZone`。  
      - `DiscardFromHand(game, player, cardIds)`：将手牌移动到 `game.DiscardPile`。  
      - 其它场景（如判定）在后续解析管线实现时按需扩展。

- **错误处理策略**  
  - 针对**可预期的非法调用**（如牌不在指定源区、源区牌不足）：
    - 首版可以通过抛出 `InvalidOperationException` 表示**编程错误**，因为上层应保证语义正确；  
    - 若未来需要将移动失败表示为可恢复结果，可引入 `CardMoveErrorCode` + 带状态的 `CardMoveResult`。  
  - 针对**内部不变式破坏**（Zone 中存在重复牌、同一牌存在于多个 Zone）：
    - 视为 bug，通过异常暴露，便于在测试阶段尽早发现。

- **幂等性与确定性要求**  
  - 在给定相同 `Game` 初始状态、相同调用序列的前提下，牌移动结果必须完全确定，不能隐式依赖 `DateTime.Now` 等外部状态。  
  - 移动过程中不得修改与牌位置无关的其它状态（例如生命值、标记），保持服务职责单一。

---

## 6. BeforeMove / AfterMove 事件结构

- **事件对象结构**  
  - `CardMoveEvent`（或拆分为 `BeforeCardMoveEvent` / `AfterCardMoveEvent`）包含：
    - `Game` 引用或最小必要字段（当前回合信息可选）；  
    - 源区/目标区标识（`ZoneId` + `OwnerSeat`）；  
    - 参与移动的牌 Id 列表及其原/新索引；  
    - `CardMoveReason` 与 `CardMoveOrdering`；  
    - 时间点（Before/After）的枚举标记。

- **发布与消费策略（当前阶段）**  
  - 当前阶段尚未引入全局 `IEventBus`：
    - 牌移动服务内部可以简单地：
      - 在方法返回值中附带 `CardMoveRecord`，供调用方按需记录；或  
      - 暴露可选的 **回调接口**（例如在构造 `BasicCardMoveService` 时注入一个简单委托）以模拟事件分发。  
  - 在未来接入事件总线后：
    - 用 `IEventBus.Publish(new CardMovedEvent(...))` 替换或补充当前回调逻辑；  
    - 保持事件 payload 结构不变，避免破坏已有技能与日志代码。

- **与技能/日志模块的边界**  
  - 本模块只定义事件数据与发布时机，不负责：
    - 决定是否有技能响应、如何改变移动行为；  
    - 如何记录到结构化日志或回放记录中。  
  - 技能与日志模块只依赖事件接口，不反向依赖牌移动服务的内部实现细节。

---

## 7. 算法与不变量

- **单次移动算法（概念步骤）**  
  1. 通过 `fromZone` / `toZone` 引用获取其内部 `MutableCards` 列表。  
  2. 在源区查找目标牌（或牌集合），若找不到则抛出异常。  
  3. 生成 `BeforeMove` 事件记录（只读快照，不修改状态）。  
  4. 从源区 `MutableCards` 中移除牌：
     - 单张时直接移除；  
     - 多张时根据要保持的相对顺序，先按索引排序后从后往前移除，避免索引错位。  
  5. 根据 `CardMoveOrdering` 决定插入到目标区的位置：
     - `ToTop`：追加到列表尾部，视为“牌堆顶”；  
     - `ToBottom`：插入到列表头部，视为“牌堆底”；  
     - `PreserveRelativeOrder`：对目标区只是单次追加，但保证多张牌的相对顺序与源区一致。  
  6. 生成 `AfterMove` 事件记录，包含新索引与最终顺序。  
  7. 返回结构化 `CardMoveResult` 给调用方。

- **关键不变量**  
  - **唯一归属**：任意时刻，每张 `Card` 实例只能出现在零个或一个 `Zone` 的 `MutableCards` 中，不允许重复引用。  
  - **数量守恒**：移动操作不会创建或销毁牌，只是在不同区之间切换；
    - 创建/销毁牌（如生成虚拟牌、移出游戏）应由更高层模块通过明确的 API 完成。  
  - **顺序一致性**：同一 Zone 内的 `Cards` 列表顺序与游戏语义一致：
    - 对 `DrawPile`：列表末尾 = 牌堆顶（或在实现中统一定义并在文档中固定）；  
    - 对 `DiscardPile`：列表末尾 = 最近一次进入弃牌堆的牌。  
  - **只通过服务修改**：完成迁移后，`GameSetup.Basic` 等模块不得再直接操作 `Zone.MutableCards`，而应使用 `ICardMoveService`。

---

## 8. 与 GameSetup.Basic 的集成点

- **当前实现回顾**（`GameSetup.Basic.cs`）  
  - `PopulateDrawPile`：
    - 直接清空 `DrawPile.MutableCards`，按洗牌结果创建 `Card` 实例并追加。  
  - `DealInitialHands`：
    - 从 `drawZone.Cards` 通过索引读取若干 `Card`，追加到 `handZone.MutableCards`；  
    - 最后重建 `DrawPile` 的列表以移除已发出的牌。

- **目标集成方式**  
  - 在 `GameSetup.Basic` 中通过依赖注入或内部构造使用 `ICardMoveService`：
    - `PopulateDrawPile` 保留为“生成整副牌并写入牌堆”的一次性操作；  
    - `DealInitialHands` 替换为：
      - 调用 `cardMoveService.DrawCards(game, player, initialHandCardCount)`，由服务内部负责从 `DrawPile` 抽牌到 `HandZone`；  
      - 不再直接操作 `MutableCards`。  
  - 这样可保证后续任何对“抽牌”的规则/技能修改，只需在牌移动服务或其修饰层中实现，无需修改 `GameSetup`。

---

## 9. 渐进式实现计划

### 阶段 1：接口与 DTO 骨架

- **目标**：在不修改现有逻辑的前提下，引入牌移动相关接口与数据结构。  
- **工作项**：
  1. 在 `LegendOfThreeKingdoms.Core.Zones` 命名空间中新建 `Zones.Abstractions.cs`：
     - 定义 `CardMoveReason`、`CardMoveOrdering`、`CardMoveDescriptor` / `CardMoveResult`；  
     - 定义 `ICardMoveService` 接口（含通用 `MoveSingle` / `MoveMany` 及 `DrawCards` / `DiscardFromHand` 等高层方法）。  
  2. 为上述类型添加 XML 注释，明确与 `Rules` / `Turns` / `Actions` 的边界。  
  3. 编写接口级的最小编译测试（例如只构造空实现）。

### 阶段 2：BasicCardMoveService 实现

- **目标**：完成最小可用的牌移动实现，并保证不变量。  
- **工作项**：
  1. 在 `Zones.Basic.cs` 中实现 `BasicCardMoveService`：
     - 基于当前 `Zone` 实现 `MoveSingle` / `MoveMany`，包含合理的参数检查与异常信息。  
     - 为 `DrawCards` / `DiscardFromHand` 提供简单封装，内部复用 `MoveMany`。  
  2. 明确 `DrawPile` / `DiscardPile` / `HandZone` 在列表中“顶/底”的约定，并在注释中固定。  
  3. 为以下场景编写单元测试：
     - 单张抽牌、多张抽牌；  
     - 弃置多张手牌，顺序保持正确；  
     - 源区牌不足或不包含指定牌时抛出异常。

### 阶段 3：集成 GameSetup.Basic

- **目标**：让初始化发牌完全依赖 `ICardMoveService` 而非直接操作 Zone。  
- **工作项**：
  1. 在 `BasicGameInitializer` 内部创建或注入一个 `BasicCardMoveService` 实例。  
  2. 重写 `DealInitialHands`：
     - 使用 `DrawCards` 为每个玩家发牌；  
     - 删除对 `Zone.MutableCards` 的手动重建逻辑。  
  3. 调整现有 `GameInitializationTests`：
     - 验证初始化后的 `DrawPile` / `HandZone` 牌数与顺序不变；  
     - 确认在固定 seed 下 determinism 维持不变。

### 阶段 4：为后续解析管线与事件系统预留挂点

- **目标**：在不实现完整 resolver / 事件总线的前提下，为后续模块保留稳定扩展点。  
- **工作项**：
  1. 在 `CardMoveResult` 中添加可选的 `CardMoveEvent` 集合或单个事件字段，表示一次移动的 Before/After 快照。  
  2. 为 `BasicCardMoveService` 添加可注入的（可选）回调委托：
     - 例如 `Action<CardMoveEvent> onBeforeMove`, `Action<CardMoveEvent> onAfterMove`；  
     - 目前默认传入 `null`，未来由事件总线适配器填充。  
  3. 在设计文档中记录：
     - 未来 `Resolution` / `Damage` / `Dying` / `EventBus` 模块应统一基于这些事件进行扩展。

---

## 10. 设计约束与最佳实践

- **与模型层解耦**  
  - 牌移动服务只依赖 `Game` 与 `IZone` / `Zone` 类型，不引入对 `Rules` / `Actions` / `Turns` 的引用，避免循环依赖。  

- **保持服务的“透明性”**  
  - 服务不做规则判断：是否允许弃这张牌、是否在合法阶段使用由规则层/解析层决定；牌移动服务只在**已经决定要移动**时执行物理移动。  

- **错误尽量早暴露**  
  - 对于内部不变式（例如同一牌同时出现在多个 Zone）：
    - 通过断言式异常尽早暴露，单元测试覆盖这些场景。  

- **为回放留好空间**  
  - 所有移动记录都应以 **可序列化的结构** 表达（只包含 Id/枚举/简单值），避免直接持有复杂引用，方便后续映射到 `ReplayRecord` 中。

---

## 11. 完成定义（Definition of Done）

- **结构与接口**：
  - `LegendOfThreeKingdoms.Core.Zones` 命名空间中的 `ICardMoveService`、`CardMoveReason` 等 DTO 定义完整，通过编译，并具备清晰 XML 注释。  
- **功能实现**：
  - `BasicCardMoveService` 能够：
    - 将牌在 `Game.DrawPile`、`Game.DiscardPile`、`Player.HandZone` 之间任意移动；  
    - 正确维护每个 Zone 的牌序与数量不变量；  
    - 对典型错误（牌不在源区、牌不足）给出明确异常。  
- **集成与测试**：
  - `BasicGameInitializer` 已改为依赖 `ICardMoveService` 分发初始手牌，且所有 `core.Tests` 中与初始化和牌数相关的测试全部通过。  
  - 新增针对 `BasicCardMoveService` 的单元测试覆盖至少：抽牌、弃牌、多张批量移动与非法移动路径。  
  - 确认在固定 seed 下，对局初始化的牌顺序与之前版本保持一致或有合理解释的更新。  
