# Dying & 救援流程技术规划（PLAN）

> 聚焦于 `core_module_breakdown.md` 中的 **13. Dying & 救援流程**，在已有 **DamageResolver** 和 **Response System** 基础上，实现濒死判断与救援流程，完成从伤害到死亡的完整闭环。

---

## 1. 范围与目标

- **范围（Scope）**
  - 在 `core` Class Library 中实现濒死与救援流程：
    - 修改 `DamageResolver`，在伤害应用后检查是否需要触发濒死流程
    - 实现 `DyingResolver`：处理濒死判断与救援轮询
    - 实现救援成功后的体力恢复逻辑
    - 实现无人救援时的死亡结算
    - 记录濒死与死亡事件到日志系统
  - 约束：
    - **不实现复杂技能介入**（如华佗的急救、桃园结义等），仅支持基础【桃】救援
    - **不实现事件总线**（将在步骤 14 实现），仅通过日志系统记录
    - **不实现复杂死亡结算**（如遗计、阵亡技等），仅标记死亡状态

- **目标（Goals）**
  - **完整闭环**：从伤害应用 → 濒死判断 → 救援轮询 → 死亡结算的完整流程
  - **可追踪**：濒死开始、救援成功/失败、死亡等关键事件都记录到日志
  - **可扩展**：为后续技能介入（如急救、桃园结义）预留接口
  - **可测试**：通过单元测试覆盖典型路径（有救援、无救援、多次救援等）

- **非目标（Non-Goals）**
  - 不实现复杂技能介入救援（步骤 16）
  - 不实现完整事件总线（步骤 14）
  - 不实现复杂死亡结算（如遗计、阵亡技等）

---

## 2. 与现有模块的关系

### 2.1 上游依赖

- **DamageResolver**（见 `core/Resolution.Basic.cs`）
  - 当前在伤害应用后，如果体力 ≤ 0，会设置 `IsAlive = false`
  - 需要修改：在设置 `IsAlive = false` 之前，先触发濒死流程
  - 如果濒死流程中无人救援，再设置 `IsAlive = false`

- **Response System**（见 `core/Response.Basic.cs` 和 `core/Response.Extensions.cs`）
  - `ResponseType.PeachForDying` 已定义（见 `core/Response.Abstractions.cs`）
  - `CalculatePeachResponderOrder` 已实现（见 `core/Response.Extensions.cs`）
  - `ResponseRuleService` 已支持 `PeachForDying`（见 `core/Rules.Basic.cs`）
  - 需要创建：`CreatePeachResponseWindow` 扩展方法（类似于 `CreateJinkResponseWindow`）

- **Resolution Pipeline**（见 `core/Resolution.Basic.cs`）
  - `IResolver` 接口：`DyingResolver` 将实现此接口
  - `IResolutionStack`：用于推入救援响应窗口和后续处理

### 2.2 下游影响

- **事件系统**（步骤 14）
  - 濒死与死亡事件将作为事件总线的输入源
  - 当前仅记录到日志系统

- **技能系统**（步骤 16）
  - 技能可以介入救援流程（如华佗的急救）
  - 当前仅支持基础【桃】救援

---

## 3. 核心设计

### 3.1 濒死流程触发时机

在 `DamageResolver` 中，伤害应用后：

1. 检查目标玩家体力是否 ≤ 0
2. 如果 `damage.TriggersDying == true`（当前始终为 true），触发濒死流程
3. 推入 `DyingResolver` 到结算栈
4. 如果濒死流程中无人救援，再设置 `IsAlive = false`

**修改位置**：`core/Resolution.Basic.cs` 中的 `DamageResolver.Resolve` 方法

### 3.2 DyingResolver 设计

实现 `IResolver` 接口，定义在 `core/Resolution.Basic.cs`：

**核心逻辑**：

1. 从 `ResolutionContext` 中提取濒死玩家信息（可通过 `IntermediateResults` 或扩展字段传递）
2. 验证濒死玩家状态（体力 ≤ 0，尚未死亡）
3. 记录濒死开始事件到日志
4. 创建救援响应窗口（使用 `ResponseType.PeachForDying`）
5. 推入响应窗口到结算栈
6. 推入 `DyingRescueHandlerResolver` 到结算栈（用于处理救援结果）

**如何传递濒死玩家信息**：

- 方案 A：通过 `ResolutionContext.IntermediateResults`（推荐）
  - `DamageResolver` 在触发濒死时，将 `DyingPlayerSeat` 写入 `IntermediateResults`
  - `DyingResolver` 从 `IntermediateResults` 读取
- 方案 B：通过 `ResolutionContext` 扩展字段
  - 添加 `DyingPlayerSeat?` 字段到 `ResolutionContext`
  - 需要修改 `ResolutionContext` 定义

**推荐方案 A**，因为：

- 不修改 `ResolutionContext` 的核心结构
- 与现有 `SlashResolver` 使用 `IntermediateResults` 的模式一致

### 3.3 救援响应窗口

创建 `CreatePeachResponseWindow` 扩展方法，定义在 `core/Response.Extensions.cs`：

**核心逻辑**：

1. 计算响应顺序：使用 `CalculatePeachResponderOrder(game, dyingPlayerSeat)`
2. 创建 `ResponseWindowContext`：
   - `ResponseType = ResponseType.PeachForDying`
   - `ResponderOrder = CalculatePeachResponderOrder(...)`
   - `SourceEvent = { Type = "Dying", DyingPlayerSeat = dyingPlayerSeat }`
3. 创建并返回 `ResponseWindowResolver`

**响应顺序规则**（已实现）：

- 濒死玩家优先（可以自救）
- 然后按座位号顺序轮询其他存活玩家

### 3.4 救援结果处理

实现 `DyingRescueHandlerResolver`，定义在 `core/Resolution.Basic.cs`：

**核心逻辑**：

1. 从 `IntermediateResults` 读取响应窗口结果
2. 如果救援成功（`ResponseWindowState.ResponseSuccess`）：
   - 恢复濒死玩家体力：`dyingPlayer.CurrentHealth = Math.Max(1, dyingPlayer.CurrentHealth + 1)`（至少恢复到 1）
   - 记录救援成功事件到日志
   - 检查是否需要继续濒死流程（如果体力仍 ≤ 0，需要再次救援）
3. 如果无人救援（`ResponseWindowState.NoResponse`）：
   - 标记玩家死亡：`dyingPlayer.IsAlive = false`
   - 记录死亡事件到日志
   - 返回成功结果

**多次救援处理**：

- 如果玩家体力仍 ≤ 0（例如受到 2 点伤害，体力为 0，使用 1 个【桃】后体力为 1，但可能还有其他伤害来源）
- 当前实现：每次救援后体力恢复为 1，如果仍 ≤ 0，需要再次触发濒死流程
- 简化处理：救援成功后，如果体力 ≤ 0，再次推入 `DyingResolver`（递归处理）

### 3.5 死亡结算

在 `DyingRescueHandlerResolver` 中，无人救援时：

1. 设置 `dyingPlayer.IsAlive = false`
2. 记录死亡事件到日志：
   - `EventType = "PlayerDied"`
   - 包含死亡玩家座位号、死亡原因等信息
3. 返回成功结果

---

## 4. 文件修改清单

### 4.1 需要修改的文件

1. **`core/Resolution.Basic.cs`**
   - 修改 `DamageResolver.Resolve`：在伤害应用后，如果体力 ≤ 0 且 `TriggersDying == true`，推入 `DyingResolver`
   - 添加 `DyingResolver` 类：实现濒死判断与救援窗口创建
   - 添加 `DyingRescueHandlerResolver` 类：处理救援结果与死亡结算

2. **`core/Response.Extensions.cs`**
   - 添加 `CreatePeachResponseWindow` 扩展方法：创建【桃】救援响应窗口

### 4.2 需要创建的文件

无（所有代码都在现有文件中添加）

### 4.3 测试文件

**`core.Tests/ResolutionTests.cs`**

- 添加测试：`dyingResolverTriggersWhenHealthReachesZero`
- 添加测试：`dyingRescueSucceedsWithPeach`
- 添加测试：`dyingRescueFailsWithoutPeach`
- 添加测试：`dyingRescueMultipleTimes`
- 添加测试：`dyingResolverLogsDyingAndDeathEvents`

---

## 5. 实现细节

### 5.1 DamageResolver 修改

在 `DamageResolver.Resolve` 方法中，伤害应用后：

```csharp
// Apply damage: reduce health (cannot go below 0)
var previousHealth = target.CurrentHealth;
target.CurrentHealth = Math.Max(0, target.CurrentHealth - damage.Amount);

// Log damage event if log sink is available
if (context.LogSink is not null)
{
    // ... log damage event ...
}

// Check if dying process should be triggered
if (target.CurrentHealth <= 0 && damage.TriggersDying)
{
    // Initialize IntermediateResults if not present
    var intermediateResults = context.IntermediateResults;
    if (intermediateResults is null)
    {
        intermediateResults = new Dictionary<string, object>();
    }
    
    // Store dying player info for DyingResolver
    intermediateResults["DyingPlayerSeat"] = target.Seat;
    
    // Create new context with IntermediateResults
    var dyingContext = new ResolutionContext(
        context.Game,
        context.SourcePlayer,
        context.Action,
        context.Choice,
        context.Stack,
        context.CardMoveService,
        context.RuleService,
        context.PendingDamage,
        context.LogSink,
        context.GetPlayerChoice,
        intermediateResults
    );
    
    // Push DyingResolver onto stack
    context.Stack.Push(new DyingResolver(), dyingContext);
}
else
{
    // Update alive status if health reaches 0 or below (only if not triggering dying)
    if (target.CurrentHealth <= 0)
    {
        target.IsAlive = false;
    }
}
```

### 5.2 DyingResolver 实现

```csharp
public sealed class DyingResolver : IResolver
{
    public ResolutionResult Resolve(ResolutionContext context)
    {
        // Extract dying player info from IntermediateResults
        var intermediateResults = context.IntermediateResults;
        if (intermediateResults is null || !intermediateResults.TryGetValue("DyingPlayerSeat", out var seatObj))
        {
            return ResolutionResult.Failure(
                ResolutionErrorCode.InvalidState,
                messageKey: "resolution.dying.noDyingPlayer");
        }
        
        if (seatObj is not int dyingPlayerSeat)
        {
            return ResolutionResult.Failure(
                ResolutionErrorCode.InvalidState,
                messageKey: "resolution.dying.invalidDyingPlayerSeat");
        }
        
        var game = context.Game;
        var dyingPlayer = game.Players.FirstOrDefault(p => p.Seat == dyingPlayerSeat);
        if (dyingPlayer is null)
        {
            return ResolutionResult.Failure(
                ResolutionErrorCode.InvalidTarget,
                messageKey: "resolution.dying.playerNotFound",
                details: new { DyingPlayerSeat = dyingPlayerSeat });
        }
        
        // Validate dying state
        if (dyingPlayer.CurrentHealth > 0 || dyingPlayer.IsAlive == false)
        {
            return ResolutionResult.Failure(
                ResolutionErrorCode.InvalidState,
                messageKey: "resolution.dying.playerNotDying",
                details: new { DyingPlayerSeat = dyingPlayerSeat, CurrentHealth = dyingPlayer.CurrentHealth });
        }
        
        // Log dying start event
        if (context.LogSink is not null)
        {
            var logEntry = new LogEntry
            {
                EventType = "DyingStart",
                Level = "Info",
                Message = $"Player {dyingPlayerSeat} is dying",
                Data = new { DyingPlayerSeat = dyingPlayerSeat, CurrentHealth = dyingPlayer.CurrentHealth }
            };
            context.LogSink.Log(logEntry);
        }
        
        // Check if GetPlayerChoice is provided (required for response window)
        if (context.GetPlayerChoice is null)
        {
            return ResolutionResult.Failure(
                ResolutionErrorCode.InvalidState,
                messageKey: "resolution.dying.getPlayerChoiceRequired");
        }
        
        // Create handler resolver context
        var handlerContext = new ResolutionContext(
            context.Game,
            context.SourcePlayer,
            context.Action,
            context.Choice,
            context.Stack,
            context.CardMoveService,
            context.RuleService,
            context.PendingDamage,
            context.LogSink,
            context.GetPlayerChoice,
            intermediateResults
        );
        
        // Push DyingRescueHandlerResolver onto stack first (will execute after response window due to LIFO)
        context.Stack.Push(new DyingRescueHandlerResolver(dyingPlayerSeat), handlerContext);
        
        // Create response window for Peach rescue
        var responseWindow = handlerContext.CreatePeachResponseWindow(
            dyingPlayerSeat: dyingPlayerSeat,
            sourceEvent: new { Type = "Dying", DyingPlayerSeat = dyingPlayerSeat },
            getPlayerChoice: context.GetPlayerChoice);
        
        // Push response window onto stack last (will execute first due to LIFO)
        context.Stack.Push(responseWindow, handlerContext);
        
        return ResolutionResult.SuccessResult;
    }
}
```

### 5.3 DyingRescueHandlerResolver 实现

```csharp
public sealed class DyingRescueHandlerResolver : IResolver
{
    private readonly int _dyingPlayerSeat;
    
    public DyingRescueHandlerResolver(int dyingPlayerSeat)
    {
        _dyingPlayerSeat = dyingPlayerSeat;
    }
    
    public ResolutionResult Resolve(ResolutionContext context)
    {
        // Read response window result from IntermediateResults
        var intermediateResults = context.IntermediateResults;
        if (intermediateResults is null || !intermediateResults.TryGetValue("LastResponseResult", out var resultObj))
        {
            return ResolutionResult.Failure(
                ResolutionErrorCode.InvalidState,
                messageKey: "resolution.dying.noResponseResult");
        }
        
        if (resultObj is not ResponseWindowResult responseResult)
        {
            return ResolutionResult.Failure(
                ResolutionErrorCode.InvalidState,
                messageKey: "resolution.dying.invalidResponseResult");
        }
        
        var game = context.Game;
        var dyingPlayer = game.Players.FirstOrDefault(p => p.Seat == _dyingPlayerSeat);
        if (dyingPlayer is null)
        {
            return ResolutionResult.Failure(
                ResolutionErrorCode.InvalidTarget,
                messageKey: "resolution.dying.playerNotFound",
                details: new { DyingPlayerSeat = _dyingPlayerSeat });
        }
        
        // Handle rescue result
        if (responseResult.State == ResponseWindowState.ResponseSuccess)
        {
            // Rescue successful - restore health to at least 1
            var previousHealth = dyingPlayer.CurrentHealth;
            dyingPlayer.CurrentHealth = Math.Max(1, dyingPlayer.CurrentHealth + 1);
            
            // Log rescue success
            if (context.LogSink is not null)
            {
                var logEntry = new LogEntry
                {
                    EventType = "DyingRescueSuccess",
                    Level = "Info",
                    Message = $"Player {responseResult.Responder?.Seat} rescued player {_dyingPlayerSeat}",
                    Data = new
                    {
                        DyingPlayerSeat = _dyingPlayerSeat,
                        RescuerSeat = responseResult.Responder?.Seat,
                        PreviousHealth = previousHealth,
                        CurrentHealth = dyingPlayer.CurrentHealth
                    }
                };
                context.LogSink.Log(logEntry);
            }
            
            // Check if still dying (health <= 0) - trigger another dying process
            if (dyingPlayer.CurrentHealth <= 0)
            {
                // Push DyingResolver again for continued rescue
                var dyingContext = new ResolutionContext(
                    context.Game,
                    context.SourcePlayer,
                    context.Action,
                    context.Choice,
                    context.Stack,
                    context.CardMoveService,
                    context.RuleService,
                    context.PendingDamage,
                    context.LogSink,
                    context.GetPlayerChoice,
                    intermediateResults
                );
                
                context.Stack.Push(new DyingResolver(), dyingContext);
            }
        }
        else if (responseResult.State == ResponseWindowState.NoResponse)
        {
            // No rescue - mark as dead
            dyingPlayer.IsAlive = false;
            
            // Log death event
            if (context.LogSink is not null)
            {
                var logEntry = new LogEntry
                {
                    EventType = "PlayerDied",
                    Level = "Info",
                    Message = $"Player {_dyingPlayerSeat} died",
                    Data = new
                    {
                        DyingPlayerSeat = _dyingPlayerSeat,
                        CurrentHealth = dyingPlayer.CurrentHealth
                    }
                };
                context.LogSink.Log(logEntry);
            }
        }
        
        return ResolutionResult.SuccessResult;
    }
}
```

### 5.4 CreatePeachResponseWindow 扩展方法

在 `core/Response.Extensions.cs` 中添加：

```csharp
public static ResponseWindowResolver CreatePeachResponseWindow(
    this ResolutionContext context,
    int dyingPlayerSeat,
    object? sourceEvent,
    Func<ChoiceRequest, ChoiceResult> getPlayerChoice)
{
    if (context is null) throw new ArgumentNullException(nameof(context));
    if (getPlayerChoice is null) throw new ArgumentNullException(nameof(getPlayerChoice));

    var game = context.Game;
    var responderOrder = CalculatePeachResponderOrder(game, dyingPlayerSeat);
    
    // Create response window context
    var responseRuleService = new ResponseRuleService();
    var windowContext = new ResponseWindowContext(
        Game: game,
        ResponseType: ResponseType.PeachForDying,
        ResponderOrder: responderOrder,
        SourceEvent: sourceEvent,
        RuleService: context.RuleService,
        ResponseRuleService: responseRuleService,
        ChoiceFactory: new ChoiceRequestFactory(),
        CardMoveService: context.CardMoveService,
        LogSink: context.LogSink
    );
    
    return new ResponseWindowResolver(windowContext, getPlayerChoice);
}
```

---

## 6. 测试策略

### 6.1 单元测试场景

1. **濒死触发测试**
   - 伤害导致体力 ≤ 0 时，触发 `DyingResolver`
   - 伤害导致体力 > 0 时，不触发濒死流程

2. **救援成功测试**
   - 濒死玩家有【桃】，自救成功
   - 队友有【桃】，救援成功
   - 救援后体力恢复为 1

3. **救援失败测试**
   - 无人有【桃】，玩家死亡
   - 死亡后 `IsAlive = false`

4. **多次救援测试**
   - 受到 2 点伤害，需要 2 个【桃】才能完全恢复
   - 使用 1 个【桃】后，仍需要继续救援

5. **日志记录测试**
   - 濒死开始事件被记录
   - 救援成功事件被记录
   - 死亡事件被记录

### 6.2 集成测试场景

- 完整流程：出杀 → 伤害 → 濒死 → 救援 → 恢复/死亡

---

## 7. 实现顺序

1. **阶段 1：修改 DamageResolver**
   - 在伤害应用后检查是否需要触发濒死流程
   - 推入 `DyingResolver` 到结算栈

2. **阶段 2：实现 DyingResolver**
   - 实现濒死判断逻辑
   - 创建救援响应窗口
   - 推入 `DyingRescueHandlerResolver`

3. **阶段 3：实现 CreatePeachResponseWindow**
   - 创建【桃】救援响应窗口扩展方法

4. **阶段 4：实现 DyingRescueHandlerResolver**
   - 处理救援结果
   - 实现体力恢复逻辑
   - 实现死亡结算

5. **阶段 5：添加测试**
   - 添加单元测试覆盖所有场景
   - 验证日志记录

---

## 8. 注意事项

1. **多次救援处理**：如果玩家受到多点伤害，可能需要多次救援。当前实现通过递归推入 `DyingResolver` 来处理。

2. **响应顺序**：`CalculatePeachResponderOrder` 已实现，濒死玩家优先，然后按座位号顺序。

3. **体力恢复规则**：每次使用【桃】恢复 1 点体力，至少恢复到 1 点。如果体力仍 ≤ 0，需要继续救援。

4. **日志记录**：所有关键事件（濒死开始、救援成功、死亡）都应记录到日志系统，便于调试和回放。

5. **扩展性**：为后续技能介入（如华佗的急救）预留接口，当前仅支持基础【桃】救援。



