# 技能介入结算与规则判断技术规划（PLAN）

> 聚焦于 `core_module_breakdown.md` 中的 **16.技能介入结算与规则判断**，让技能可以订阅事件总线，在关键节点改写行为，修改出牌次数上限、响应机会、伤害数值等。

---

## 1. 范围与目标

- **范围（Scope）**：
  - 在 `core` Class Library 中，基于既有的**事件总线（IEventBus）**、**技能系统（ISkill/SkillManager）**和**规则服务（IRuleService/IRuleModifier）**，实现技能对规则判断和结算流程的介入机制。
  - 让技能可以修改规则判断结果（如出牌次数上限、目标范围、响应机会等）。
  - 让技能可以介入结算流程（如修改伤害值、替换效果等）。
  - 保持接口简洁，通过 `ModifyXxxContext` 或返回"修饰过的参数对象"的方式减少耦合。

- **目标（Goals）**：
  - **规则修改**：技能可以通过 `IRuleModifier` 接口修改规则判断结果。
  - **结算介入**：技能可以通过订阅事件总线，在关键结算节点（如伤害创建、响应窗口开启等）修改结算上下文。
  - **可扩展**：通过接口和事件机制，支持未来添加新的介入点。
  - **解耦**：技能通过标准接口和事件介入，不直接依赖具体的规则服务或结算器实现。

- **非目标（Non-Goals）**：
  - 不实现复杂的技能优先级和冲突解决机制（将在后续阶段实现）。
  - 不处理技能的选择请求和玩家交互（这些将在后续阶段实现）。
  - 不实现技能的冷却机制和使用次数限制（将在后续阶段实现）。

---

## 2. 与现有模块的关系

### 2.1 上游依赖

- **事件总线（已在第14项实现）**：
  - `IEventBus`：技能通过订阅事件总线来响应结算事件（如 `DamageCreatedEvent`, `PhaseStartEvent` 等）。
  - `IGameEvent`：所有游戏事件的基础接口。

- **技能系统（已在第15项实现）**：
  - `ISkill`：技能接口，技能可以实现 `IRuleModifier` 来修改规则。
  - `SkillManager`：技能管理器，提供查询玩家技能的能力。
  - `SkillRegistry`：技能注册中心。

- **规则服务（已在第4项实现）**：
  - `IRuleService`：规则服务主接口。
  - `IRuleModifier`：规则修饰器接口，用于修改规则判断结果。
  - `IRuleModifierProvider`：规则修饰器提供者接口，用于获取应用于特定玩家的修饰器。
  - `CardUsageContext`、`ResponseContext`：规则判断上下文。

- **结算系统（已在第9-13项实现）**：
  - `IResolver`、`ResolutionContext`：结算器接口和上下文。
  - `DamageDescriptor`：伤害描述符。
  - `DamageCreatedEvent`、`DamageAppliedEvent`：伤害相关事件。

- **限制规则服务（已在第4项实现）**：
  - `ILimitRuleService`：次数限制规则服务，如 `GetMaxSlashPerTurn`。

### 2.2 下游被依赖方

- **复杂互动样例（第20项，后续实现）**：
  - 技能介入机制将支持复杂装备技能（如青龙偃月刀）的实现。

- **扩展内容包（第19项，后续实现）**：
  - 新武将和技能将使用技能介入机制来实现复杂效果。

---

## 3. 模块划分与命名建议

在 `core` 项目中，为技能介入层建议如下命名空间与文件布局：

- `LegendOfThreeKingdoms.Core.Skills`：技能层根命名空间（已存在）
  - `Skills.Modifiers.cs`：技能规则修饰器实现（`SkillRuleModifier`, `SkillRuleModifierProvider`）
  - `Skills.Interventions.cs`：技能结算介入实现（如伤害修改、响应机会修改等）

- `LegendOfThreeKingdoms.Core.Rules`：规则层根命名空间（已存在）
  - `Rules.Basic.cs`：修改 `RuleService` 构造函数，支持技能修饰器提供者

- `LegendOfThreeKingdoms.Core.Resolution`：结算层根命名空间（已存在）
  - `Resolution.Basic.cs`：在关键结算节点发布可修改的事件（如 `DamageCreatedEvent`）

---

## 4. 核心抽象设计

### 4.1 技能规则修饰器

**`SkillRuleModifier` 类**（在 `Skills.Modifiers.cs` 中实现）：

- 实现 `IRuleModifier` 接口，包装一个 `ISkill` 实例。
- 将技能的能力转换为规则修改逻辑：
  - `ModifyCanUseCard`：检查技能是否有 `SkillCapability.ModifiesRules` 能力，如果有，调用技能的规则修改方法。
  - `ModifyCanRespondWithCard`：类似处理响应规则。
  - `ModifyValidateAction`：类似处理动作验证。

**`SkillRuleModifierProvider` 类**（在 `Skills.Modifiers.cs` 中实现）：

- 实现 `IRuleModifierProvider` 接口。
- 持有 `SkillManager` 引用，根据玩家查询其激活的技能。
- 将具有 `SkillCapability.ModifiesRules` 能力的技能包装为 `SkillRuleModifier` 并返回。

### 4.2 技能规则修改接口扩展

**扩展 `ISkill` 接口**（在 `Skills.Abstractions.cs` 中）：

- 添加可选的方法，让技能可以直接实现规则修改逻辑：
  - `RuleResult? ModifyCanUseCard(RuleResult current, CardUsageContext context)` - 返回 null 表示不修改，返回非 null 表示修改后的结果。
  - `RuleResult? ModifyCanRespondWithCard(RuleResult current, ResponseContext context)` - 类似。
  - `RuleResult? ModifyValidateAction(RuleResult current, RuleContext context, ActionDescriptor action, ChoiceRequest? choice)` - 类似。

**或者，创建新的接口**（在 `Skills.Abstractions.cs` 中）：

- `IRuleModifyingSkill` 接口，继承 `ISkill`，添加规则修改方法。
- 技能可以选择实现 `IRuleModifyingSkill` 来提供规则修改能力。

### 4.3 技能结算介入机制

**可修改的事件类型**：

- 对于需要在结算过程中被修改的事件，创建可修改的包装类型：
  - `ModifiableDamageCreatedEvent`：包装 `DamageCreatedEvent`，允许技能修改伤害值。
  - 或者，在 `DamageCreatedEvent` 发布前，先发布一个 `BeforeDamageCreatedEvent`，技能可以订阅并修改即将创建的伤害。

**技能结算介入接口**（在 `Skills.Abstractions.cs` 中）：

- `IResolutionInterveningSkill` 接口，继承 `ISkill`，添加结算介入方法：
  - `DamageDescriptor? ModifyDamage(DamageDescriptor original, Game game, Player owner)` - 返回 null 表示不修改，返回非 null 表示修改后的伤害描述符。
  - `int? ModifyMaxSlashPerTurn(int current, Game game, Player owner)` - 修改杀次数上限。

### 4.4 限制规则服务的扩展

**扩展 `ILimitRuleService` 接口**（在 `Rules.Abstractions.cs` 中）：

- 添加技能介入点：
  - `int GetMaxSlashPerTurn(Game game, Player player)` - 当前实现固定返回 1，需要支持技能修改。
  - 或者，在 `RuleService` 中调用 `ILimitRuleService.GetMaxSlashPerTurn` 后，通过 `IRuleModifierProvider` 获取修饰器并应用修改。

**实现策略**：

- 方案A：在 `LimitRuleService` 中注入 `SkillManager`，查询玩家技能并应用修改。
- 方案B：在 `RuleService.CanUseCard` 中，先获取基础限制，然后通过 `IRuleModifierProvider` 应用技能修改。
- **推荐方案B**：保持 `ILimitRuleService` 的简单性，在 `RuleService` 层面统一处理技能修改。

---

## 5. 实现细节

### 5.1 技能规则修饰器实现

**`SkillRuleModifier` 类**：

```csharp
public sealed class SkillRuleModifier : IRuleModifier
{
    private readonly ISkill _skill;
    private readonly Game _game;
    private readonly Player _owner;

    public SkillRuleModifier(ISkill skill, Game game, Player owner)
    {
        _skill = skill ?? throw new ArgumentNullException(nameof(skill));
        _game = game ?? throw new ArgumentNullException(nameof(game));
        _owner = owner ?? throw new ArgumentNullException(nameof(owner));
    }

    public RuleResult ModifyCanUseCard(RuleResult current, CardUsageContext context)
    {
        if (!_skill.IsActive(_game, _owner))
            return current;

        if ((_skill.Capabilities & SkillCapability.ModifiesRules) == 0)
            return current;

        if (_skill is IRuleModifyingSkill ruleModifyingSkill)
        {
            var modified = ruleModifyingSkill.ModifyCanUseCard(current, context);
            return modified ?? current;
        }

        return current;
    }

    // 类似实现 ModifyCanRespondWithCard 和 ModifyValidateAction
}
```

**`SkillRuleModifierProvider` 类**：

```csharp
public sealed class SkillRuleModifierProvider : IRuleModifierProvider
{
    private readonly SkillManager _skillManager;

    public SkillRuleModifierProvider(SkillManager skillManager)
    {
        _skillManager = skillManager ?? throw new ArgumentNullException(nameof(skillManager));
    }

    public IReadOnlyList<IRuleModifier> GetModifiersFor(Game game, Player player)
    {
        var skills = _skillManager.GetActiveSkills(game, player);
        var modifiers = new List<IRuleModifier>();

        foreach (var skill in skills)
        {
            if ((skill.Capabilities & SkillCapability.ModifiesRules) != 0)
            {
                modifiers.Add(new SkillRuleModifier(skill, game, player));
            }
        }

        return modifiers;
    }
}
```

### 5.2 技能规则修改接口

**`IRuleModifyingSkill` 接口**（在 `Skills.Abstractions.cs` 中）：

```csharp
public interface IRuleModifyingSkill : ISkill
{
    /// <summary>
    /// Modifies the result of CanUseCard rule check.
    /// Returns null if no modification is needed, otherwise returns the modified result.
    /// </summary>
    RuleResult? ModifyCanUseCard(RuleResult current, CardUsageContext context);

    /// <summary>
    /// Modifies the result of CanRespondWithCard rule check.
    /// Returns null if no modification is needed, otherwise returns the modified result.
    /// </summary>
    RuleResult? ModifyCanRespondWithCard(RuleResult current, ResponseContext context);

    /// <summary>
    /// Modifies the result of ValidateAction rule check.
    /// Returns null if no modification is needed, otherwise returns the modified result.
    /// </summary>
    RuleResult? ModifyValidateAction(RuleResult current, RuleContext context, ActionDescriptor action, ChoiceRequest? choice);
}
```

### 5.3 修改次数上限的实现

**在 `RuleService.CanUseCard` 中处理次数限制**：

当前 `CardUsageRuleService.CanUseCard` 中已经调用了 `_limitRules.GetMaxSlashPerTurn(game, source)`，但这是基础限制。

需要扩展 `CardUsageContext` 或创建新的上下文类型，支持技能修改后的限制值。

**方案**：在 `RuleService.CanUseCard` 中：
1. 获取基础限制值（通过 `ILimitRuleService`）。
2. 通过 `IRuleModifierProvider` 获取修饰器。
3. 创建一个新的上下文类型 `LimitModificationContext`，让修饰器可以修改限制值。
4. 应用修改后的限制值。

**或者更简单的方案**：扩展 `IRuleModifier` 接口，添加 `int? ModifyMaxSlashPerTurn(int current, Game game, Player player)` 方法。

**推荐方案**：扩展 `IRuleModifier` 接口，添加限制修改方法：

```csharp
public interface IRuleModifier
{
    // 现有方法...
    
    /// <summary>
    /// Modifies the maximum number of Slash cards a player can use per turn.
    /// Returns null if no modification is needed, otherwise returns the modified value.
    /// </summary>
    int? ModifyMaxSlashPerTurn(int current, Game game, Player player);
}
```

然后在 `RuleService` 或 `CardUsageRuleService` 中应用这些修改。

### 5.4 技能结算介入实现

**伤害修改机制**：

在 `DamageResolver` 中，发布 `DamageCreatedEvent` 之前，先发布一个 `BeforeDamageCreatedEvent`，技能可以订阅并修改伤害：

```csharp
// 在 DamageResolver 中
var baseDamage = new DamageDescriptor(...);

// 发布 BeforeDamageCreatedEvent，允许技能修改
var beforeEvent = new BeforeDamageCreatedEvent(game, baseDamage);
if (context.EventBus is not null)
{
    context.EventBus.Publish(beforeEvent);
}

// 使用修改后的伤害
var finalDamage = beforeEvent.ModifiedDamage ?? baseDamage;

// 继续结算...
```

**`BeforeDamageCreatedEvent` 事件**（在 `Events.Abstractions.cs` 中）：

```csharp
public sealed record BeforeDamageCreatedEvent(
    Game Game,
    DamageDescriptor OriginalDamage,
    DateTime Timestamp = default
) : IGameEvent
{
    public DateTime Timestamp { get; init; } = Timestamp == default ? DateTime.UtcNow : Timestamp;
    
    /// <summary>
    /// The modified damage descriptor. If null, use OriginalDamage.
    /// Skills can set this to modify the damage.
    /// </summary>
    public DamageDescriptor? ModifiedDamage { get; set; }
}
```

**技能订阅并修改**：

```csharp
public void Attach(Game game, Player owner, IEventBus eventBus)
{
    _game = game;
    _owner = owner;
    _eventBus = eventBus;
    eventBus.Subscribe<BeforeDamageCreatedEvent>(OnBeforeDamageCreated);
}

private void OnBeforeDamageCreated(BeforeDamageCreatedEvent evt)
{
    if (evt.OriginalDamage.TargetSeat != _owner.Seat)
        return;
    
    if (!IsActive(_game, _owner))
        return;
    
    // 修改伤害值（例如：减少1点伤害）
    var modified = evt.OriginalDamage with { Amount = Math.Max(1, evt.OriginalDamage.Amount - 1) };
    evt.ModifiedDamage = modified;
}
```

### 5.5 完善 ExtraSlashSkill 实现

**`ExtraSlashSkill` 类**（在 `Skills.Basic.cs` 中修改）：

- 实现 `IRuleModifyingSkill` 接口。
- 在 `ModifyMaxSlashPerTurn` 方法中，将限制值从 1 增加到 2（或更多）。

```csharp
public sealed class ExtraSlashSkill : BaseSkill, IRuleModifyingSkill
{
    // 现有实现...

    public int? ModifyMaxSlashPerTurn(int current, Game game, Player owner)
    {
        if (!IsActive(game, owner))
            return null;
        
        // 将限制值增加1
        return current + 1;
    }

    public RuleResult? ModifyCanUseCard(RuleResult current, CardUsageContext context)
    {
        // 如果需要，可以在这里修改使用牌的规则
        return null; // 不修改
    }

    // 其他方法返回 null 表示不修改
}
```

---

## 6. 文件结构

需要创建/修改的文件：

**新建文件**：
- `core/Skills.Modifiers.cs` - 技能规则修饰器实现（`SkillRuleModifier`, `SkillRuleModifierProvider`）
- `core/Skills.Interventions.cs` - 技能结算介入相关实现（可选，如果逻辑复杂）

**修改文件**：
- `core/Skills.Abstractions.cs` - 添加 `IRuleModifyingSkill` 接口
- `core/Skills.Basic.cs` - 修改 `ExtraSlashSkill` 实现 `IRuleModifyingSkill` 接口
- `core/Rules.Abstractions.cs` - 扩展 `IRuleModifier` 接口，添加 `ModifyMaxSlashPerTurn` 方法
- `core/Rules.Basic.cs` - 修改 `RuleService` 构造函数，支持 `SkillRuleModifierProvider`；修改 `CardUsageRuleService.CanUseCard`，应用技能对次数限制的修改
- `core/Events.Abstractions.cs` - 添加 `BeforeDamageCreatedEvent` 事件（如果需要）
- `core/Resolution.Basic.cs` - 在 `DamageResolver` 中发布 `BeforeDamageCreatedEvent` 并应用修改

**测试文件**（可选，不在本计划范围内）：
- `core.Tests/SkillsModifiersTests.cs` - 技能修饰器单元测试
- `core.Tests/SkillInterventionTests.cs` - 技能结算介入单元测试

---

## 7. 实现步骤

### 阶段1：技能规则修饰器基础

1. 扩展 `IRuleModifier` 接口，添加 `ModifyMaxSlashPerTurn` 方法。
2. 创建 `IRuleModifyingSkill` 接口。
3. 实现 `SkillRuleModifier` 类，包装技能并实现 `IRuleModifier`。
4. 实现 `SkillRuleModifierProvider` 类，从 `SkillManager` 获取技能并转换为修饰器。
5. 修改 `RuleService` 构造函数，支持注入 `SkillRuleModifierProvider`。
6. 修改 `CardUsageRuleService.CanUseCard`，应用技能对次数限制的修改。

### 阶段2：完善 ExtraSlashSkill

1. 修改 `ExtraSlashSkill` 实现 `IRuleModifyingSkill` 接口。
2. 实现 `ModifyMaxSlashPerTurn` 方法，将限制值增加1。
3. 更新 `ExtraSlashSkill` 的 `Capabilities` 为 `SkillCapability.ModifiesRules`。

### 阶段3：技能结算介入（可选，如果需要在当前阶段实现）

1. 添加 `BeforeDamageCreatedEvent` 事件。
2. 修改 `DamageResolver`，在创建伤害前发布 `BeforeDamageCreatedEvent`。
3. 创建示例技能，订阅 `BeforeDamageCreatedEvent` 并修改伤害值。

---

## 8. 实现注意事项

1. **修饰器顺序**：多个技能修饰器可能同时修改同一个规则判断。当前实现按顺序应用所有修饰器，后续可能需要优先级机制。

2. **性能考虑**：每次规则判断都会查询玩家技能并创建修饰器。如果性能成为问题，可以考虑缓存修饰器实例。

3. **事件修改的线程安全**：当前实现假设单线程环境。`BeforeDamageCreatedEvent` 的 `ModifiedDamage` 属性是可变的，需要确保在事件发布后、使用前不会被其他代码修改。

4. **技能激活检查**：在应用技能修改前，必须检查技能是否激活（通过 `IsActive` 方法）。

5. **空值处理**：技能修改方法返回 `null` 表示不修改，返回非 `null` 表示修改后的值。需要正确处理 `null` 值。

6. **向后兼容**：扩展 `IRuleModifier` 接口时，需要确保现有实现（如 `NoOpRuleModifierProvider`）仍然可以编译。新方法应该有默认实现或返回 `null`。

---

## 9. 依赖关系

```
EventBus (第14项，已实现)
    ↓
ISkill, SkillManager (第15项，已实现)
    ↓
IRuleModifier, IRuleModifierProvider (第4项，已实现)
    ↓
SkillRuleModifier, SkillRuleModifierProvider (本计划)
    ↓
RuleService 集成技能修饰器 (本计划)
    ↓
复杂互动样例 (第20项，后续实现)
```

---

## 10. 测试建议

建议为以下组件编写单元测试：

1. **SkillRuleModifier**：
   - 包装技能并正确调用规则修改方法
   - 检查技能激活状态
   - 检查技能能力标记

2. **SkillRuleModifierProvider**：
   - 从 SkillManager 获取技能并转换为修饰器
   - 只返回具有 `ModifiesRules` 能力的技能
   - 处理没有技能的情况

3. **ExtraSlashSkill**：
   - 正确实现 `ModifyMaxSlashPerTurn`，将限制值增加1
   - 只在技能激活时修改
   - 正确处理边界情况（如限制值已经是最大值）

4. **RuleService 集成**：
   - 使用 `SkillRuleModifierProvider` 时，技能修改被正确应用
   - 多个技能修饰器按顺序应用
   - 技能未激活时不应用修改

5. **伤害修改机制**（如果实现）：
   - 技能可以订阅 `BeforeDamageCreatedEvent` 并修改伤害
   - 修改后的伤害被正确应用到结算流程
   - 多个技能可以同时修改伤害（按订阅顺序）

---

## 11. 后续扩展方向

1. **技能优先级系统**：为技能添加优先级，确保某些技能在其他技能之前执行。

2. **更复杂的规则修改**：支持修改目标范围、响应机会、牌的使用条件等。

3. **结算流程替换**：支持技能完全替换某个结算步骤（如"当你受到伤害时，改为摸2张牌"）。

4. **技能链式触发**：支持技能触发其他技能，形成技能链。

5. **技能状态持久化**：支持保存和恢复技能状态，用于回放和断线重连。

6. **性能优化**：缓存修饰器实例，减少重复查询和创建。



