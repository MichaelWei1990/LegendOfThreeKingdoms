# 三国杀 Core 动作与 Choice 描述对象技术规划（PLAN）

> 聚焦于 `core_module_breakdown.md` 中的 **5. 动作与 Choice 描述对象**，在既有规则服务与模型层基础上，定义统一的 **动作（Action）与选择（Choice）描述 DTO 及相关服务接口**，为 UI / 网络层和 Resolver / Response 系统提供稳定的交互契约。

---

## 1. 范围与目标

- **范围（Scope）**：
  - 在 `core` Class Library 中，围绕以下能力设计并实现数据结构与服务接口（不写任何具体 UI / 网络代码）：
    - **可执行动作列表描述**（`ActionDescriptor` 及其相关结构）。
    - **玩家交互选择请求/结果描述**（`ChoiceRequest` / `ChoiceResult` 及其细分类型）。
    - **动作与选择之间的编排关系**（从 Action 到 Choice，再到 Resolver 的桥接契约）。
  - 基于已规划的 `Rules` 层（参见 `02.04_BasicRuleServicesAndQueries_PLAN.md`）和模型层（Game/Player/Card/Zone），实现一组 **只读、可序列化的 DTO + 轻量服务**。

- **目标（Goals）**：
  - **统一描述**：为“使用牌、结束阶段、发动技能、响应事件”等行为提供统一的 `ActionDescriptor` 结构，避免 UI/网络层依赖具体规则实现细节。
  - **交互抽象**：通过 `ChoiceRequest` / `ChoiceResult` 抽象所有“玩家选择”过程，使上层只需要处理“请求 → 显示 → 回传结果”，而不关注规则细节。
  - **Resolver 友好**：保证每个 `ActionDescriptor` + `ChoiceResult` 组合都能映射到一个 **确定的 Resolver 调用**（例如 `UseCardResolver`, `SlashResolver`），减少胶水代码。
  - **可测试**：所有描述对象为普通 DTO，可在单元测试中构造并验证序列化/反序列化与流转逻辑。

- **非目标（Non-Goals）**：
  - 不在本 PLAN 中设计完整的 UI 协议（例如具体 JSON Schema、前端组件布局）。
  - 不处理网络会话管理、超时、重连等问题，只关心“一个选择请求与其对应的结果”的结构。
  - 不在本层实现复杂多阶段交互（如连锁选择、嵌套响应），但需要为后续扩展预留基本结构。

---

## 2. 与现有模块的关系

### 2.1 上游依赖

- **模型层（Game / Player / Card / Zone）**：
  - 提供动作与选择所需的基础状态信息：当前玩家、阶段、手牌、可选目标玩家列表等。
- **规则层（Rule & Query Layer，参见 `02.04_BasicRuleServicesAndQueries_PLAN.md`）**：
  - `IRuleService`、`IActionQueryService` 等接口负责根据当前状态与规则计算：
    - 当前玩家的可用动作集合；
    - 每个动作需要的目标/牌/布尔确认等选择约束；
    - 某些动作/选择是否合法及原因。

### 2.2 下游被依赖方

- **回合与阶段引擎（Turn/Phase Engine）**：
  - 调用 `IActionQueryService` 获取当前玩家可执行的 `ActionDescriptor` 列表，用于驱动回合流程（例如出牌阶段可以 `UseSlash`, `UsePeach`, `EndPhase`）。
- **Resolver 层（UseCardResolver / SlashResolver / DamageResolver 等）**：
  - 接收上层根据 `ActionDescriptor` 和 `ChoiceResult` 组装好的“已决策动作”，执行实际状态变更与结算。
- **Response System**：
  - 基于内部事件触发响应窗口，生成 `ChoiceRequest`（例如“是否打出【闪】？”），等待 `ChoiceResult` 后再进入后续 Resolver。
- **UI / 网络层**：
  - 不直接读写 `Game` 状态，仅与 `ActionDescriptor` / `ChoiceRequest` / `ChoiceResult` 进行交互，实现界面展示与玩家输入收集。

---

## 3. 命名空间与文件布局建议

- `LegendOfThreeKingdoms.Core.Actions`：动作与 Choice 的根命名空间。
  - `LegendOfThreeKingdoms.Core.Actions.Abstractions`：
    - 核心 DTO：`ActionDescriptor`, `ChoiceRequest`, `ChoiceResult` 及相关枚举/子类型。
    - 服务接口：`IActionQueryService`, `IChoiceRequestFactory`, `IActionExecutionValidator` 等。
  - `LegendOfThreeKingdoms.Core.Actions.Basic`：
    - 针对基础规则集（杀/闪/桃 + 基础阶段）下的默认实现。
  - `LegendOfThreeKingdoms.Core.Actions.Mapping`：
    - `ActionDescriptor` ↔ Resolver 调用之间的映射与工厂（例如 `IActionResolutionMapper`）。

> 与 `LegendOfThreeKingdoms.Core.Rules` 命名空间保持对齐，确保后续在引用上形成清晰分层：`Model` → `Rules` → `Actions` → `Resolvers`/`Response`/UI。

---

## 4. Action 描述对象设计（ActionDescriptor）

### 4.1 基本职责

- 对外（UI / 网络层）表达：
  - 当前玩家 **可以** 发起哪些“高层动作”（UseCard / EndPhase / ActivateSkill / Respond / Cancel 等）。
- 对内（Resolver / Rules 层）承载：
  - 执行该动作所需的最小上下文信息与约束，便于后续根据 `ActionDescriptor + ChoiceResult` 直接进入对应的 Resolver 流程。

### 4.2 核心结构要素

> 以下仅描述字段语义，不给出具体代码签名。

- **标识字段**：
  - `ActionId`：全局唯一或在当前上下文唯一的动作标识，用于在 UI 选择后回传；
  - `ActionType`：枚举，表示动作类型，例如：
    - `UseCard`, `RespondWithCard`, `EndPhase`, `ActivateSkill`, `Confirm`, 等；
  - `SourcePlayerId`：发起该动作的玩家标识；
  - `PhaseSnapshot`：可选，对当前阶段/子阶段做一个快照，便于重放与调试。

- **与牌相关的信息**：
  - `CardId`：如果该动作绑定到具体一张牌（如“使用手中某一张【杀】”），则记录其唯一 ID；
  - `CardCategory`：如果是“从一组牌中选择一张再使用”（如“使用任意一张【杀】”），则记录允许的牌类别过滤条件；
  - `CardZone`：指示牌所在区域（手牌/装备/判定区等），便于 UI 渲染与 Resolver 校验。

- **目标与选择约束摘要**：
  - `RequiresTargets`：是否需要选择目标；
  - `TargetConstraints`：
    - `MinTargets`, `MaxTargets`；
    - `AllowedTargetIds` 或 `TargetFilterType`（敌方 / 任意 / 阵营内等，初期可简化为“当前规则计算出的候选列表”）；
  - `RequiresAdditionalChoice`：执行前是否还需要触发额外 Choice（例如二段选择、是否发动某被动效果等），初期可为 false，仅保留字段。

- **显示/本地化辅助字段**：
  - `DisplayKey`：用于 UI 文案映射（例如 `action.use_slash`）；
  - `IconKey`：可选，用于前端图标选择（不影响核心逻辑）。

### 4.3 与规则层协作

- `IActionQueryService.GetAvailableActions(game, player)`：
  - 基于 `IRuleService` 的判定结果构建一组 `ActionDescriptor`：
    - 对每个可用的牌类型/行为生成对应动作；
    - 对“结束阶段”等不涉及牌的行为生成纯动作描述；
    - 对每个需要目标的动作，将 `TargetConstraints` 填充为当前合法目标的约束摘要。

- `ActionDescriptor` **不修改状态**，仅为后续的 Choice 和 Resolver 流程提供输入模板。

---

## 5. Choice 描述对象设计（ChoiceRequest / ChoiceResult）

### 5.1 设计原则

- **统一抽象**：不论是“选目标”、“选牌”、“确认/否认”、“在多个选项中择一”，都统一通过 `ChoiceRequest`/`ChoiceResult` 表达。
- **与动作解耦**：`ChoiceRequest` 可以由：
  - 某个 `ActionDescriptor` 衍生（例如 UseSlash 需要选择目标）；
  - Response System 直接发起（例如“是否打出【闪】？”）；
  - Resolver 流程中某一步产生（例如某锦囊牌需要二次选项）。

### 5.2 ChoiceRequest 结构

- **基础字段**：
  - `RequestId`：唯一标识，用于匹配对应的 `ChoiceResult`；
  - `PlayerId`：需要做出选择的玩家；
  - `RelatedActionId`：可选，若本次选择是为某个 `ActionDescriptor` 服务，记录其 ID；
  - `ChoiceType`：枚举，如：
    - `SelectTargets`, `SelectCards`, `Confirm`, `SelectOption`, `SelectOrder` 等。

- **约束信息**：
  - `TargetConstraints`：
    - `MinTargets`, `MaxTargets`；
    - `AllowedTargetIds`；
    - 可选：`MustBeAlive`, `ExcludeSelf`, `CampRestriction` 等布尔/枚举约束；
  - `CardConstraints`：
    - `MinCards`, `MaxCards`；
    - `AllowedCardIds` 或 `CardFilter` 条件（例如只允许类型为 Slash 的手牌）；
    - 可选：指示牌必须来自某个 `Zone`（手牌/装备/判定区）；
  - `Options`：
    - 对 `SelectOption` 类型，提供一组选项（含 `OptionId`, `DisplayKey`）。

- **展示辅助**：
  - `PromptKey`：用于 UI 提示文案（如 `prompt.select_targets_for_slash`）；
  - `Timeout`：可选，作为上层控制超时策略的参考，不在 core 内强制执行。

### 5.3 ChoiceResult 结构

- **基础字段**：
  - `RequestId`：与 `ChoiceRequest` 对应；
  - `PlayerId`：实际做出选择的玩家（应与请求中一致，作为安全校验）；

- **结果内容**：
  - `SelectedTargetIds`：玩家最终选择的目标列表（`SelectTargets` 时使用）；
  - `SelectedCardIds`：选中的牌 ID 列表（`SelectCards` 时使用）；
  - `SelectedOptionId`：`SelectOption` 时选中的选项；
  - `Confirmed`：`Confirm` 类型的确认结果（true/false）。

- **校验与错误处理**：
  - 在进入 Resolver 之前，通过 `IActionExecutionValidator` 或规则层的 `ValidateActionBeforeResolve`：
    - 检查结果是否满足 `ChoiceRequest` 的约束；
    - 若不满足，返回结构化错误信息（错误码 + 提示），由上层决定是否重新请求选择或直接失败。

---

## 6. 动作 → Choice → Resolver 流程编排

### 6.1 典型流程：使用【杀】（Slash）

1. **获取可用动作**：
   - 回合引擎调用 `IActionQueryService.GetAvailableActions(game, currentPlayer)`；
   - 规则层判断当前玩家可以使用若干张【杀】，为每一张或每一类别生成 `ActionDescriptor`：
     - `ActionType = UseCard`；
     - 绑定具体 `CardId` 或 `CardCategory = Slash`；
     - `TargetConstraints` 中包含当前合法目标的候选与数量范围（通常 `Min=1, Max=1`）。

2. **玩家在 UI 中选择一个 Action**：
   - 上层根据 `ActionDescriptor` 渲染按钮/可点击区域；
   - 玩家点击“使用杀”动作，UI 将 `ActionId` 回传给引擎。

3. **生成目标选择请求（ChoiceRequest）**：
   - 通过 `IChoiceRequestFactory.CreateForAction(actionDescriptor, game)` 生成一个 `ChoiceRequest`：
     - `ChoiceType = SelectTargets`；
     - `TargetConstraints` 与 `ActionDescriptor.TargetConstraints` 对齐；
     - `RelatedActionId = actionDescriptor.ActionId`。

4. **玩家完成选择，返回 ChoiceResult**：
   - UI 根据 `ChoiceRequest` 展示可点击的目标；
   - 玩家选定目标后，构造 `ChoiceResult` 并回传。

5. **进入 Resolver**：
   - 引擎调用 `IActionResolutionMapper.Resolve(actionDescriptor, choiceResult, game)`：
     - 根据 `ActionType` 与字段映射到 `UseCardResolver`；
     - `UseCardResolver` 内部使用规则服务进行最终合法性校验，再执行实际牌移动与结算。

### 6.2 典型流程：被杀响应【闪】（Jink）

1. **SlashResolver 命中目标后，触发 Response Window**；
2. **Response System** 为当前被杀玩家生成一个 `ChoiceRequest`：
   - `ChoiceType = SelectCards` 或 `Confirm + 隐式选牌`；
   - `CardConstraints` 仅允许【闪】或视为【闪】的牌；
   - `PromptKey = prompt.respond_with_jink`。
3. 玩家在 UI 中选择是否打出【闪】，并返回对应的 `ChoiceResult`；
4. Response System 使用 `ChoiceResult`：
   - 若有合法 `SelectedCardId`，则进入“打出闪”的 Resolver；
   - 否则视为未响应，继续伤害流程。

---

## 7. 接口与服务设计

### 7.1 IActionQueryService

- **职责**：按当前游戏状态与规则，生成当前玩家可执行的 `ActionDescriptor` 列表。
- **关键方法（仅描述语义）**：
  - `GetAvailableActions(game, player)`：
    - 汇总：
      - 基础使用牌动作：`UseSlash`, `UsePeach`；
      - 基础阶段控制：`EndPhase`；
      - 后续可扩展的技能/响应动作。
- **实现要点**：
  - 内部调用 `IRuleService` / `ICardUsageRuleService` / `ILimitRuleService` 等；
  - 不做任何状态变更，仅组合规则结果生成 DTO。

### 7.2 IChoiceRequestFactory

- **职责**：根据 `ActionDescriptor` 或内部事件上下文，构造相应的 `ChoiceRequest`。
- **常见入口**：
  - `CreateForAction(actionDescriptor, game)`：从动作生成初始选择请求；
  - `CreateForResponse(responseContext)`：从响应窗口上下文生成选择请求；
  - 未来可扩展：`CreateForSkillActivation(skillContext)` 等。

### 7.3 IActionExecutionValidator / IChoiceValidator

- **职责**：在 Resolver 执行前，对 `ActionDescriptor + ChoiceResult` 组合进行最终合法性校验：
  - 判断 `ChoiceResult` 是否满足原始 `ChoiceRequest` 约束；
  - 再次调用规则服务确认在当前最新状态下仍然合法（防止并发/延迟导致状态变化）。

- **典型方法**：
  - `Validate(game, actionDescriptor, choiceResult)`：返回结构化结果（bool + 错误码）。

### 7.4 IActionResolutionMapper

- **职责**：将动作+选择映射到具体 Resolver 调用：
  - 例如：`UseCard` + `CardType = Slash` → `SlashResolver`；
  - `EndPhase` → `PhaseEngine.AdvancePhase()`；
- **实现策略**：
  - 初期可使用简单的 `switch`/映射表；
  - 后续可引入配置/注册机制，支持扩展包动态添加新动作类型。

---

## 8. 分阶段实现计划

### 阶段 1：核心 DTO 与最小接口

- **目标**：在不依赖完整 Resolver / Response 系统的前提下，先稳定 `ActionDescriptor` / `ChoiceRequest` / `ChoiceResult` 的基础结构与命名。
- **工作项**：
  1. 在 `LegendOfThreeKingdoms.Core.Actions.Abstractions` 中定义：
     - DTO：`ActionDescriptor`, `ChoiceRequest`, `ChoiceResult`；
     - 枚举：`ActionType`, `ChoiceType` 及少量基础错误码/约束枚举；
     - 接口：`IActionQueryService`, `IChoiceRequestFactory`, `IActionExecutionValidator`, `IActionResolutionMapper`（仅签名）。
  2. 对齐 `02.04_BasicRuleServicesAndQueries_PLAN.md` 中已有的 `ActionDescriptor` / `Choice*` 概念，避免重复与命名冲突。
  3. 为上述 DTO 编写基础单元测试：
     - 构造典型的 Slash/Peach/EndPhase 动作描述；
     - 构造简单的目标/牌选择请求与结果，验证序列化与字段一致性。

### 阶段 2：基础实现（杀/闪/桃 + 阶段控制）

- **目标**：让基础出牌流程可以通过 `ActionDescriptor + ChoiceRequest/Result` 串起最小闭环（从查询动作到进入 Resolver）。
- **工作项**：
  1. 在 `LegendOfThreeKingdoms.Core.Actions.Basic` 中实现：
     - `ActionQueryService`：
       - 出牌阶段：生成 `UseSlash`, `UsePeach`, `EndPhase` 等动作；
       - 回合外暂可不生成动作（由 Response System 单独处理）。
     - `ChoiceRequestFactory`：
       - 为 `UseSlash` 生成 `SelectTargets` 请求；
       - 为 Response System 提供 `CreateForResponse` 的最小实现（仅支持【闪】响应【杀】）。
     - `ActionExecutionValidator`：
       - 对 Slash/Peach/EndPhase 场景进行最小校验（目标合法性、牌是否仍然存在等）。
  2. 在集成测试中串联：
     - 手动构造 `Game` + 玩家 + 手牌；
     - 调用 `GetAvailableActions` → 选择 `UseSlash` → 生成 `ChoiceRequest` → 构造 `ChoiceResult`；
     - 确认能被映射到对应 Resolver（即使 Resolver 逻辑暂时是最小实现）。

### 阶段 3：与 Response System / SkillEngine 的扩展点

- **目标**：在不实现所有复杂技能的前提下，保证 `Actions` 层能够自然扩展以支持更多交互场景。
- **工作项**：
  1. 与未来 `ResponseSystem` 规划对齐：
     - 预留 `ChoiceRequest` 中的字段，如 `ResponseWindowId`, `CanPass`（是否允许“过”），但初期可不使用；
  2. 为技能扩展预留 hook：
     - 允许技能通过装饰器/注册表影响 `ActionQueryService` 的输出（添加或修改动作）；
     - 允许技能为动作附加额外 Choice（例如“是否发动连营，在摸牌阶段多摸一张？”）。
  3. 在 `ActionResolutionMapper` 中使用可扩展映射表：
     - 初期内置 Slash/Peach/EndPhase；
     - 预留接口供后续扩展包注册新动作类型及对应 Resolver。

---

## 9. 设计约束与最佳实践

- **DTO 纯净性**：
  - `ActionDescriptor` / `ChoiceRequest` / `ChoiceResult` 不应持有对可变 `Game` 对象的引用，仅使用 ID/快照字段；
  - 便于在网络上传输、在日志/回放中持久化。

- **向后兼容**：
  - 字段设计时为未来扩展保留一定冗余（例如可选字段、枚举预留值），避免频繁破坏性变更。

- **错误码统一**：
  - 与 `Rules` 层的 `RuleResult` / `RuleErrorCode` 对齐，避免 UI/日志中出现两套不兼容的错误语义。

- **与回放系统的衔接**：
  - 回放记录中可直接存储 `ActionDescriptor` 的关键字段 + `ChoiceResult` 内容，保证对局可重放与调试。

---

## 10. 完成定义（Definition of Done）

- **结构与接口**：
  - `LegendOfThreeKingdoms.Core.Actions.Abstractions` 中的 DTO 与接口定义完整，通过编译，并与 `02.04_BasicRuleServicesAndQueries_PLAN.md` 保持命名/职责一致。
- **基础实现**：
  - `ActionQueryService` / `ChoiceRequestFactory` / `ActionExecutionValidator` / `ActionResolutionMapper` 在基础规则场景下可用：
    - 能为出牌阶段生成合理的 `UseSlash`/`UsePeach`/`EndPhase` 动作；
    - 能为【杀】和【闪】相关流程生成并消费对应的 `ChoiceRequest`/`ChoiceResult`。
- **测试**：
  - 覆盖“出杀 → 选目标 → 校验 → 进入 Resolver”、“被杀 → 询问闪 → 返回结果”的关键路径单元/集成测试。
- **文档对齐**：
  - 本 `02.05_ActionAndChoiceDescriptors_PLAN.md` 已引用并对齐 `core_module_breakdown.md` 与 `02.04_BasicRuleServicesAndQueries_PLAN.md` 中的相关内容，且不会与其它 PLAN 文档的职责产生明显重叠。